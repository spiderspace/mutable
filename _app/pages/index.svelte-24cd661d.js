import{C as kt,S as Cl,i as Ol,n as Dl,e as s,t,j as i,c as l,a as r,g as a,d as o,m as h,b as d,K as M,f as kl,F as e,L as Al,s as Ge,J as Ml,M as Qe,N as Il,O as $l}from"../chunks/vendor-7ffe92ef.js";const yl=u=>{const{subscribe:c,set:p}=kt({value:u});return{subscribe:c,update:m=>{if(m){const f=m(u);f!==void 0&&f!==u&&(u=f)}p({value:u})},set:m=>{u=m,p({value:u})}}},Sl=u=>{let c=!1;const p={value:u},m={value:u},{subscribe:f,set:y}=kt(p);return{subscribe:f,update:C=>{if(C){const _=C(u);_!==void 0&&_!==u&&(u=p.value=m.value=_)}y((c=!c)?m:p)},set:C=>{u=p.value=m.value=C,y((c=!c)?m:p)}}};function Hl(u){let c,p,m,f,y,C,_,ae,g,W,X,se,O,Y,Z,I,at,v,At,It,$t,$,S,le,Je=u[0].get("a")+"",st,St,oe,Ht,Nt,B,Pt,Ss="{",Tt,Rt,Lt,re,qt,jt,F,Vt,ce,Wt,Bt,Ft,H,ne,de,ze=u[1].get("a")+"",lt,Ut,Kt,ue,Gt,Qt,x,Jt,ie,zt,Xt,Yt,D,Zt,he,xt,ea,ve,ta,aa,sa,N,be,pe,Xe=u[3].value.get("a")+"",ot,la,oa,U,ra,Hs="{",ca,na,da,K,ua,me,ia,ha,va,P,T,fe,Ye=u[4].value.get("a")+"",rt,ba,Ee,pa,ma,_e,fa,Ea,G,_a,Ns="{",ga,wa,Ma,Q,ya,ge,Ca,Oa,Da,R,k,we,Ze=u[2].value.get("a")+"",ct,ka,Me,Aa,Ia,ye,$a,Sa,Ha,Ce,Na,Pa,J,Ta,Oe,Ra,La,qa,L,A,De,xe=u[5].value.get("a")+"",nt,ja,ke,Va,Wa,Ae,Ba,Fa,Ua,z,Ka,Ps="{",Ga,Qa,Ja,za,Xa,Ie,Ya,Za,E,$e,xa,Se,es,ts,et,as,ss,tt,ls,os,q,rs,He,cs,ns,Ne,ds,us,is,j,hs,Pe,vs,bs,Te,ps,ms,fs,V,Es,Re,_s,gs,Le,ws,Ms,ys,Cs,Os,qe,je,Ds,ks,Ts;return{c(){c=s("main"),p=s("header"),m=s("h1"),f=s("a"),y=t("svelte-mutable-store"),C=i(),_=s("blockquote"),ae=t("using mutable values in Svelte stores with the "),g=s("code"),W=t("immutable"),X=t(" compiler flag"),se=i(),O=s("button"),Y=t("click me to make number++ go up"),Z=i(),I=s("h2"),at=t("A. "),v=s("code"),At=t("writable"),It=t(" store (broken! D:)"),$t=i(),$=s("section"),S=s("div"),le=s("span"),st=t(Je),St=t(`
			\u2190 fails to update as a `),oe=s("code"),Ht=t("writable"),Nt=t(" store because "),B=s("code"),Pt=t("immutable="),Tt=t(Ss),Rt=t("true}"),Lt=i(),re=s("pre"),qt=t(`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),jt=i(),F=s("h2"),Vt=t("B. cloned "),ce=s("code"),Wt=t("writable"),Bt=t(" store"),Ft=i(),H=s("section"),ne=s("div"),de=s("span"),lt=t(ze),Ut=t(`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),Kt=i(),ue=s("pre"),Gt=t(`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),Qt=i(),x=s("blockquote"),Jt=t("in the examples below, notice that you need to access "),ie=s("code"),zt=t(".value"),Xt=t(" for reads, unlike above"),Yt=i(),D=s("h2"),Zt=t("C. "),he=s("code"),xt=t("derived"),ea=t(" from "),ve=s("code"),ta=t("writable"),aa=t(" store"),sa=i(),N=s("section"),be=s("div"),pe=s("span"),ot=t(Xe),la=t(`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),oa=i(),U=s("pre"),ra=t("const derivedWritableMap = derived(writableMap, ($v) => ("),ca=t(Hs),na=t("value: $v}));"),da=i(),K=s("h2"),ua=t("D. "),me=s("code"),ia=t("mutable"),ha=t(" store"),va=i(),P=s("section"),T=s("div"),fe=s("span"),rt=t(Ye),ba=t(`
			\u2190 works because it's a `),Ee=s("code"),pa=t("mutable"),ma=t(` store; doesn't clone the map; however notice that
			you need to access `),_e=s("code"),fa=t(".value"),Ea=i(),G=s("pre"),_a=t("mutableMap.update(($v) => "),ga=t(Ns),wa=t(`
	$v.set('a', $v.get('a') + 1);
});`),Ma=i(),Q=s("h2"),ya=t("E. "),ge=s("code"),Ca=t("mutable"),Oa=t(" store antipattern"),Da=i(),R=s("section"),k=s("div"),we=s("span"),ct=t(Ze),ka=t(`
			\u2190 works because it's a `),Me=s("code"),Aa=t("mutable"),Ia=t(` store, but mutates the value directly and then
			manually calls `),ye=s("code"),$a=t(".update()"),Sa=t(", which seems like an antipattern"),Ha=i(),Ce=s("pre"),Na=t(`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),Pa=i(),J=s("h2"),Ta=t("F. "),Oe=s("code"),Ra=t("fastMutable"),La=t(" store"),qa=i(),L=s("section"),A=s("div"),De=s("span"),nt=t(xe),ja=t(`
			\u2190 works because it's a `),ke=s("code"),Va=t("fastMutable"),Wa=t(` store, which compared to
			`),Ae=s("code"),Ba=t("mutable"),Fa=t(` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),Ua=i(),z=s("pre"),Ka=t("fastMutableMap.update(($v) => "),Ga=t(Ps),Qa=t(`
	$v.set('a', $v.get('a') + 1);
});`),Ja=i(),za=s("hr"),Xa=i(),Ie=s("h2"),Ya=t("notes:"),Za=i(),E=s("ul"),$e=s("li"),xa=t("Why care about the immutable option? See this example: "),Se=s("a"),es=t("https://svelte.dev/examples/immutable-data"),ts=i(),et=s("li"),as=t(`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),ss=i(),tt=s("li"),ls=t(`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),os=i(),q=s("li"),rs=t("Is "),He=s("code"),cs=t("fastMutable"),ns=t(`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=s("code"),ds=t("mutable"),us=t(" implementation be preferred in all cases?"),is=i(),j=s("li"),hs=t("Are there bettes names than "),Pe=s("code"),vs=t("mutable"),bs=t(" and "),Te=s("code"),ps=t("fastMutable"),ms=t("?"),fs=i(),V=s("li"),Es=t("Add a "),Re=s("code"),_s=t("set"),gs=t(" store method? Probably useful for "),Le=s("code"),ws=t("bind:"),Ms=t(" usage in some cases\n			and less code than `update` to replace references."),ys=i(),Cs=s("hr"),Os=i(),qe=s("footer"),je=s("a"),Ds=t("public domain source code on GitHub"),this.h()},l(b){c=l(b,"MAIN",{class:!0});var n=r(c);p=l(n,"HEADER",{});var dt=r(p);m=l(dt,"H1",{class:!0});var Rs=r(m);f=l(Rs,"A",{href:!0});var Ls=r(f);y=a(Ls,"svelte-mutable-store"),Ls.forEach(o),Rs.forEach(o),C=h(dt),_=l(dt,"BLOCKQUOTE",{});var ut=r(_);ae=a(ut,"using mutable values in Svelte stores with the "),g=l(ut,"CODE",{class:!0});var qs=r(g);W=a(qs,"immutable"),qs.forEach(o),X=a(ut," compiler flag"),ut.forEach(o),dt.forEach(o),se=h(n),O=l(n,"BUTTON",{class:!0});var js=r(O);Y=a(js,"click me to make number++ go up"),js.forEach(o),Z=h(n),I=l(n,"H2",{class:!0});var it=r(I);at=a(it,"A. "),v=l(it,"CODE",{class:!0});var Vs=r(v);At=a(Vs,"writable"),Vs.forEach(o),It=a(it," store (broken! D:)"),it.forEach(o),$t=h(n),$=l(n,"SECTION",{});var ht=r($);S=l(ht,"DIV",{});var Ve=r(S);le=l(Ve,"SPAN",{class:!0});var Ws=r(le);st=a(Ws,Je),Ws.forEach(o),St=a(Ve,`
			\u2190 fails to update as a `),oe=l(Ve,"CODE",{class:!0});var Bs=r(oe);Ht=a(Bs,"writable"),Bs.forEach(o),Nt=a(Ve," store because "),B=l(Ve,"CODE",{class:!0});var vt=r(B);Pt=a(vt,"immutable="),Tt=a(vt,Ss),Rt=a(vt,"true}"),vt.forEach(o),Ve.forEach(o),Lt=h(ht),re=l(ht,"PRE",{class:!0});var Fs=r(re);qt=a(Fs,`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Fs.forEach(o),ht.forEach(o),jt=h(n),F=l(n,"H2",{class:!0});var bt=r(F);Vt=a(bt,"B. cloned "),ce=l(bt,"CODE",{class:!0});var Us=r(ce);Wt=a(Us,"writable"),Us.forEach(o),Bt=a(bt," store"),bt.forEach(o),Ft=h(n),H=l(n,"SECTION",{});var pt=r(H);ne=l(pt,"DIV",{});var As=r(ne);de=l(As,"SPAN",{class:!0});var Ks=r(de);lt=a(Ks,ze),Ks.forEach(o),Ut=a(As,`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),As.forEach(o),Kt=h(pt),ue=l(pt,"PRE",{class:!0});var Gs=r(ue);Gt=a(Gs,`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),Gs.forEach(o),pt.forEach(o),Qt=h(n),x=l(n,"BLOCKQUOTE",{});var mt=r(x);Jt=a(mt,"in the examples below, notice that you need to access "),ie=l(mt,"CODE",{class:!0});var Qs=r(ie);zt=a(Qs,".value"),Qs.forEach(o),Xt=a(mt," for reads, unlike above"),mt.forEach(o),Yt=h(n),D=l(n,"H2",{class:!0});var We=r(D);Zt=a(We,"C. "),he=l(We,"CODE",{class:!0});var Js=r(he);xt=a(Js,"derived"),Js.forEach(o),ea=a(We," from "),ve=l(We,"CODE",{class:!0});var zs=r(ve);ta=a(zs,"writable"),zs.forEach(o),aa=a(We," store"),We.forEach(o),sa=h(n),N=l(n,"SECTION",{});var ft=r(N);be=l(ft,"DIV",{});var Is=r(be);pe=l(Is,"SPAN",{class:!0});var Xs=r(pe);ot=a(Xs,Xe),Xs.forEach(o),la=a(Is,`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),Is.forEach(o),oa=h(ft),U=l(ft,"PRE",{class:!0});var Et=r(U);ra=a(Et,"const derivedWritableMap = derived(writableMap, ($v) => ("),ca=a(Et,Hs),na=a(Et,"value: $v}));"),Et.forEach(o),ft.forEach(o),da=h(n),K=l(n,"H2",{class:!0});var _t=r(K);ua=a(_t,"D. "),me=l(_t,"CODE",{class:!0});var Ys=r(me);ia=a(Ys,"mutable"),Ys.forEach(o),ha=a(_t," store"),_t.forEach(o),va=h(n),P=l(n,"SECTION",{});var gt=r(P);T=l(gt,"DIV",{});var Be=r(T);fe=l(Be,"SPAN",{class:!0});var Zs=r(fe);rt=a(Zs,Ye),Zs.forEach(o),ba=a(Be,`
			\u2190 works because it's a `),Ee=l(Be,"CODE",{class:!0});var xs=r(Ee);pa=a(xs,"mutable"),xs.forEach(o),ma=a(Be,` store; doesn't clone the map; however notice that
			you need to access `),_e=l(Be,"CODE",{class:!0});var el=r(_e);fa=a(el,".value"),el.forEach(o),Be.forEach(o),Ea=h(gt),G=l(gt,"PRE",{class:!0});var wt=r(G);_a=a(wt,"mutableMap.update(($v) => "),ga=a(wt,Ns),wa=a(wt,`
	$v.set('a', $v.get('a') + 1);
});`),wt.forEach(o),gt.forEach(o),Ma=h(n),Q=l(n,"H2",{class:!0});var Mt=r(Q);ya=a(Mt,"E. "),ge=l(Mt,"CODE",{class:!0});var tl=r(ge);Ca=a(tl,"mutable"),tl.forEach(o),Oa=a(Mt," store antipattern"),Mt.forEach(o),Da=h(n),R=l(n,"SECTION",{});var yt=r(R);k=l(yt,"DIV",{});var ee=r(k);we=l(ee,"SPAN",{class:!0});var al=r(we);ct=a(al,Ze),al.forEach(o),ka=a(ee,`
			\u2190 works because it's a `),Me=l(ee,"CODE",{class:!0});var sl=r(Me);Aa=a(sl,"mutable"),sl.forEach(o),Ia=a(ee,` store, but mutates the value directly and then
			manually calls `),ye=l(ee,"CODE",{class:!0});var ll=r(ye);$a=a(ll,".update()"),ll.forEach(o),Sa=a(ee,", which seems like an antipattern"),ee.forEach(o),Ha=h(yt),Ce=l(yt,"PRE",{class:!0});var ol=r(Ce);Na=a(ol,`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),ol.forEach(o),yt.forEach(o),Pa=h(n),J=l(n,"H2",{class:!0});var Ct=r(J);Ta=a(Ct,"F. "),Oe=l(Ct,"CODE",{class:!0});var rl=r(Oe);Ra=a(rl,"fastMutable"),rl.forEach(o),La=a(Ct," store"),Ct.forEach(o),qa=h(n),L=l(n,"SECTION",{});var Ot=r(L);A=l(Ot,"DIV",{});var te=r(A);De=l(te,"SPAN",{class:!0});var cl=r(De);nt=a(cl,xe),cl.forEach(o),ja=a(te,`
			\u2190 works because it's a `),ke=l(te,"CODE",{class:!0});var nl=r(ke);Va=a(nl,"fastMutable"),nl.forEach(o),Wa=a(te,` store, which compared to
			`),Ae=l(te,"CODE",{class:!0});var dl=r(Ae);Ba=a(dl,"mutable"),dl.forEach(o),Fa=a(te,` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),te.forEach(o),Ua=h(Ot),z=l(Ot,"PRE",{class:!0});var Dt=r(z);Ka=a(Dt,"fastMutableMap.update(($v) => "),Ga=a(Dt,Ps),Qa=a(Dt,`
	$v.set('a', $v.get('a') + 1);
});`),Dt.forEach(o),Ot.forEach(o),Ja=h(n),za=l(n,"HR",{}),Xa=h(n),Ie=l(n,"H2",{class:!0});var ul=r(Ie);Ya=a(ul,"notes:"),ul.forEach(o),Za=h(n),E=l(n,"UL",{});var w=r(E);$e=l(w,"LI",{});var $s=r($e);xa=a($s,"Why care about the immutable option? See this example: "),Se=l($s,"A",{href:!0});var il=r(Se);es=a(il,"https://svelte.dev/examples/immutable-data"),il.forEach(o),$s.forEach(o),ts=h(w),et=l(w,"LI",{});var hl=r(et);as=a(hl,`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),hl.forEach(o),ss=h(w),tt=l(w,"LI",{});var vl=r(tt);ls=a(vl,`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),vl.forEach(o),os=h(w),q=l(w,"LI",{});var Fe=r(q);rs=a(Fe,"Is "),He=l(Fe,"CODE",{class:!0});var bl=r(He);cs=a(bl,"fastMutable"),bl.forEach(o),ns=a(Fe,`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=l(Fe,"CODE",{class:!0});var pl=r(Ne);ds=a(pl,"mutable"),pl.forEach(o),us=a(Fe," implementation be preferred in all cases?"),Fe.forEach(o),is=h(w),j=l(w,"LI",{});var Ue=r(j);hs=a(Ue,"Are there bettes names than "),Pe=l(Ue,"CODE",{class:!0});var ml=r(Pe);vs=a(ml,"mutable"),ml.forEach(o),bs=a(Ue," and "),Te=l(Ue,"CODE",{class:!0});var fl=r(Te);ps=a(fl,"fastMutable"),fl.forEach(o),ms=a(Ue,"?"),Ue.forEach(o),fs=h(w),V=l(w,"LI",{});var Ke=r(V);Es=a(Ke,"Add a "),Re=l(Ke,"CODE",{class:!0});var El=r(Re);_s=a(El,"set"),El.forEach(o),gs=a(Ke," store method? Probably useful for "),Le=l(Ke,"CODE",{class:!0});var _l=r(Le);ws=a(_l,"bind:"),_l.forEach(o),Ms=a(Ke," usage in some cases\n			and less code than `update` to replace references."),Ke.forEach(o),w.forEach(o),ys=h(n),Cs=l(n,"HR",{}),Os=h(n),qe=l(n,"FOOTER",{class:!0});var gl=r(qe);je=l(gl,"A",{href:!0});var wl=r(je);Ds=a(wl,"public domain source code on GitHub"),wl.forEach(o),gl.forEach(o),n.forEach(o),this.h()},h(){d(f,"href","https://github.com/spiderspace/svelte-mutable-store"),d(m,"class","svelte-1hmclby"),d(g,"class","svelte-1hmclby"),d(O,"class","svelte-1hmclby"),d(v,"class","svelte-1hmclby"),d(I,"class","svelte-1hmclby"),d(le,"class","count svelte-1hmclby"),d(oe,"class","svelte-1hmclby"),d(B,"class","svelte-1hmclby"),d(re,"class","panel-inset svelte-1hmclby"),M($,"--hue",u[12](u[0].get("a")),!1),d(ce,"class","svelte-1hmclby"),d(F,"class","svelte-1hmclby"),d(de,"class","count svelte-1hmclby"),d(ue,"class","panel-inset svelte-1hmclby"),M(H,"--hue",u[12](u[1].get("a")),!1),d(ie,"class","svelte-1hmclby"),d(he,"class","svelte-1hmclby"),d(ve,"class","svelte-1hmclby"),d(D,"class","svelte-1hmclby"),d(pe,"class","count svelte-1hmclby"),d(U,"class","panel-inset svelte-1hmclby"),M(N,"--hue",u[12](u[3].value.get("a")),!1),d(me,"class","svelte-1hmclby"),d(K,"class","svelte-1hmclby"),d(fe,"class","count svelte-1hmclby"),d(Ee,"class","svelte-1hmclby"),d(_e,"class","svelte-1hmclby"),d(G,"class","panel-inset svelte-1hmclby"),M(P,"--hue",u[12](u[4].value.get("a")),!1),d(ge,"class","svelte-1hmclby"),d(Q,"class","svelte-1hmclby"),d(we,"class","count svelte-1hmclby"),d(Me,"class","svelte-1hmclby"),d(ye,"class","svelte-1hmclby"),d(Ce,"class","panel-inset svelte-1hmclby"),M(R,"--hue",u[12](u[2].value.get("a")),!1),d(Oe,"class","svelte-1hmclby"),d(J,"class","svelte-1hmclby"),d(De,"class","count svelte-1hmclby"),d(ke,"class","svelte-1hmclby"),d(Ae,"class","svelte-1hmclby"),d(z,"class","panel-inset svelte-1hmclby"),M(L,"--hue",u[12](u[5].value.get("a")),!1),d(Ie,"class","svelte-1hmclby"),d(Se,"href","https://svelte.dev/examples/immutable-data"),d(He,"class","svelte-1hmclby"),d(Ne,"class","svelte-1hmclby"),d(Pe,"class","svelte-1hmclby"),d(Te,"class","svelte-1hmclby"),d(Re,"class","svelte-1hmclby"),d(Le,"class","svelte-1hmclby"),d(je,"href","https://github.com/spiderspace/svelte-mutable-store"),d(qe,"class","svelte-1hmclby"),d(c,"class","markup svelte-1hmclby")},m(b,n){kl(b,c,n),e(c,p),e(p,m),e(m,f),e(f,y),e(p,C),e(p,_),e(_,ae),e(_,g),e(g,W),e(_,X),e(c,se),e(c,O),e(O,Y),e(c,Z),e(c,I),e(I,at),e(I,v),e(v,At),e(I,It),e(c,$t),e(c,$),e($,S),e(S,le),e(le,st),e(S,St),e(S,oe),e(oe,Ht),e(S,Nt),e(S,B),e(B,Pt),e(B,Tt),e(B,Rt),e($,Lt),e($,re),e(re,qt),e(c,jt),e(c,F),e(F,Vt),e(F,ce),e(ce,Wt),e(F,Bt),e(c,Ft),e(c,H),e(H,ne),e(ne,de),e(de,lt),e(ne,Ut),e(H,Kt),e(H,ue),e(ue,Gt),e(c,Qt),e(c,x),e(x,Jt),e(x,ie),e(ie,zt),e(x,Xt),e(c,Yt),e(c,D),e(D,Zt),e(D,he),e(he,xt),e(D,ea),e(D,ve),e(ve,ta),e(D,aa),e(c,sa),e(c,N),e(N,be),e(be,pe),e(pe,ot),e(be,la),e(N,oa),e(N,U),e(U,ra),e(U,ca),e(U,na),e(c,da),e(c,K),e(K,ua),e(K,me),e(me,ia),e(K,ha),e(c,va),e(c,P),e(P,T),e(T,fe),e(fe,rt),e(T,ba),e(T,Ee),e(Ee,pa),e(T,ma),e(T,_e),e(_e,fa),e(P,Ea),e(P,G),e(G,_a),e(G,ga),e(G,wa),e(c,Ma),e(c,Q),e(Q,ya),e(Q,ge),e(ge,Ca),e(Q,Oa),e(c,Da),e(c,R),e(R,k),e(k,we),e(we,ct),e(k,ka),e(k,Me),e(Me,Aa),e(k,Ia),e(k,ye),e(ye,$a),e(k,Sa),e(R,Ha),e(R,Ce),e(Ce,Na),e(c,Pa),e(c,J),e(J,Ta),e(J,Oe),e(Oe,Ra),e(J,La),e(c,qa),e(c,L),e(L,A),e(A,De),e(De,nt),e(A,ja),e(A,ke),e(ke,Va),e(A,Wa),e(A,Ae),e(Ae,Ba),e(A,Fa),e(L,Ua),e(L,z),e(z,Ka),e(z,Ga),e(z,Qa),e(c,Ja),e(c,za),e(c,Xa),e(c,Ie),e(Ie,Ya),e(c,Za),e(c,E),e(E,$e),e($e,xa),e($e,Se),e(Se,es),e(E,ts),e(E,et),e(et,as),e(E,ss),e(E,tt),e(tt,ls),e(E,os),e(E,q),e(q,rs),e(q,He),e(He,cs),e(q,ns),e(q,Ne),e(Ne,ds),e(q,us),e(E,is),e(E,j),e(j,hs),e(j,Pe),e(Pe,vs),e(j,bs),e(j,Te),e(Te,ps),e(j,ms),e(E,fs),e(E,V),e(V,Es),e(V,Re),e(Re,_s),e(V,gs),e(V,Le),e(Le,ws),e(V,Ms),e(c,ys),e(c,Cs),e(c,Os),e(c,qe),e(qe,je),e(je,Ds),ks||(Ts=Al(O,"click",u[13]),ks=!0)},p(b,[n]){n&1&&Je!==(Je=b[0].get("a")+"")&&Ge(st,Je),n&1&&M($,"--hue",b[12](b[0].get("a")),!1),n&2&&ze!==(ze=b[1].get("a")+"")&&Ge(lt,ze),n&2&&M(H,"--hue",b[12](b[1].get("a")),!1),n&8&&Xe!==(Xe=b[3].value.get("a")+"")&&Ge(ot,Xe),n&8&&M(N,"--hue",b[12](b[3].value.get("a")),!1),n&16&&Ye!==(Ye=b[4].value.get("a")+"")&&Ge(rt,Ye),n&16&&M(P,"--hue",b[12](b[4].value.get("a")),!1),n&4&&Ze!==(Ze=b[2].value.get("a")+"")&&Ge(ct,Ze),n&4&&M(R,"--hue",b[12](b[2].value.get("a")),!1),n&32&&xe!==(xe=b[5].value.get("a")+"")&&Ge(nt,xe),n&32&&M(L,"--hue",b[12](b[5].value.get("a")),!1)},i:Ml,o:Ml,d(b){b&&o(c),ks=!1,Ts()}}}function Nl(u,c,p){let m,f,y,C,_,ae;const g=[["a",1]],W=kt(new Map(g));Qe(u,W,v=>p(0,m=v));const X=kt(new Map(g));Qe(u,X,v=>p(1,f=v));const se=Il(W,v=>({value:v}));Qe(u,se,v=>p(3,C=v));const O=yl(new Map(g));Qe(u,O,v=>p(4,_=v));const Y=yl(new Map(g));Qe(u,Y,v=>p(2,y=v));const Z=Sl(new Map(g));return Qe(u,Z,v=>p(5,ae=v)),[m,f,y,C,_,ae,W,X,se,O,Y,Z,v=>v*37+"",()=>{m.set("a",m.get("a")+1),W.set(m),f.set("a",f.get("a")+1),$l(X,f=new Map(f),f),O.update(v=>{v.set("a",v.get("a")+1)}),y.value.set("a",y.value.get("a")+1),Y.update(),Z.update(v=>{v.set("a",v.get("a")+1)})}]}class Tl extends Cl{constructor(c){super();Ol(this,c,Nl,Hl,Dl,{})}}export{Tl as default};
