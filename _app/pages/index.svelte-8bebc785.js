import{C as At,S as kl,i as Al,n as Il,e as s,t,j as i,c as l,a as r,g as a,d as o,m as h,b as d,K as M,f as $l,F as e,L as Sl,s as Ke,J as Ol,M as Qe,N as Hl,O as Nl}from"../chunks/vendor-7ffe92ef.js";const Dl=u=>{const{subscribe:n,set:p}=At({value:u});return{subscribe:n,update:m=>{if(m){const f=m(u);f!==void 0&&f!==u&&(u=f)}p({value:u})},set:m=>{u=m,p({value:u})}}},Pl=u=>{let n=!1;const p={value:u},m={value:u},{subscribe:f,set:y}=At(p);return{subscribe:f,update:C=>{if(C){const E=C(u);E!==void 0&&E!==u&&(u=p.value=m.value=E)}y((n=!n)?m:p)},set:C=>{u=p.value=m.value=C,y((n=!n)?m:p)}}};function Tl(u){let n,p,m,f,y,C,E,ae,g,W,X,I,Y,Z,O,st,lt,b,It,se,$t,St,Ht,$,S,le,Je=u[0].get("a")+"",ot,Nt,oe,Pt,Tt,B,Rt,Ns="{",Lt,qt,jt,re,Vt,Wt,F,Bt,ne,Ft,Gt,Ut,H,ce,de,ze=u[1].get("a")+"",rt,Kt,Qt,ue,Jt,zt,x,Xt,ie,Yt,Zt,xt,D,ea,he,ta,aa,be,sa,la,oa,N,ve,pe,Xe=u[3].value.get("a")+"",nt,ra,na,G,ca,Ps="{",da,ua,ia,U,ha,me,ba,va,pa,P,T,fe,Ye=u[4].value.get("a")+"",ct,ma,Ee,fa,Ea,_e,_a,ga,K,wa,Ts="{",Ma,ya,Ca,Q,Oa,ge,Da,ka,Aa,R,k,we,Ze=u[2].value.get("a")+"",dt,Ia,Me,$a,Sa,ye,Ha,Na,Pa,Ce,Ta,Ra,J,La,Oe,qa,ja,Va,L,A,De,xe=u[5].value.get("a")+"",ut,Wa,ke,Ba,Fa,Ae,Ga,Ua,Ka,z,Qa,Rs="{",Ja,za,Xa,Ya,Za,Ie,xa,es,_,$e,ts,Se,as,ss,et,ls,os,tt,rs,ns,q,cs,He,ds,us,Ne,is,hs,bs,j,vs,Pe,ps,ms,Te,fs,Es,_s,V,gs,Re,ws,Ms,Le,ys,Cs,Os,Ds,ks,qe,je,As,Is,Ls;return{c(){n=s("main"),p=s("header"),m=s("h1"),f=s("a"),y=t("svelte-mutable-store"),C=i(),E=s("blockquote"),ae=t("using mutable values in Svelte stores with the "),g=s("code"),W=t("immutable"),X=t(` compiler flag.
			`),I=s("a"),Y=t("learn more on GitHub"),Z=i(),O=s("button"),st=t("click me to make number++ go up"),lt=i(),b=s("h2"),It=t("A. "),se=s("code"),$t=t("writable"),St=t(" store (broken! D:)"),Ht=i(),$=s("section"),S=s("div"),le=s("span"),ot=t(Je),Nt=t(`
			\u2190 fails to update as a `),oe=s("code"),Pt=t("writable"),Tt=t(" store because "),B=s("code"),Rt=t("immutable="),Lt=t(Ns),qt=t("true}"),jt=i(),re=s("pre"),Vt=t(`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Wt=i(),F=s("h2"),Bt=t("B. cloned "),ne=s("code"),Ft=t("writable"),Gt=t(" store"),Ut=i(),H=s("section"),ce=s("div"),de=s("span"),rt=t(ze),Kt=t(`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),Qt=i(),ue=s("pre"),Jt=t(`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),zt=i(),x=s("blockquote"),Xt=t("in the examples below, notice that you need to access "),ie=s("code"),Yt=t(".value"),Zt=t(" for reads, unlike above"),xt=i(),D=s("h2"),ea=t("C. "),he=s("code"),ta=t("derived"),aa=t(" from "),be=s("code"),sa=t("writable"),la=t(" store"),oa=i(),N=s("section"),ve=s("div"),pe=s("span"),nt=t(Xe),ra=t(`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),na=i(),G=s("pre"),ca=t("const derivedWritableMap = derived(writableMap, ($v) => ("),da=t(Ps),ua=t("value: $v}));"),ia=i(),U=s("h2"),ha=t("D. "),me=s("code"),ba=t("mutable"),va=t(" store"),pa=i(),P=s("section"),T=s("div"),fe=s("span"),ct=t(Ye),ma=t(`
			\u2190 works because it's a `),Ee=s("code"),fa=t("mutable"),Ea=t(` store; doesn't clone the map; however notice that
			you need to access `),_e=s("code"),_a=t(".value"),ga=i(),K=s("pre"),wa=t("mutableMap.update(($v) => "),Ma=t(Ts),ya=t(`
	$v.set('a', $v.get('a') + 1);
});`),Ca=i(),Q=s("h2"),Oa=t("E. "),ge=s("code"),Da=t("mutable"),ka=t(" store antipattern"),Aa=i(),R=s("section"),k=s("div"),we=s("span"),dt=t(Ze),Ia=t(`
			\u2190 works because it's a `),Me=s("code"),$a=t("mutable"),Sa=t(` store, but mutates the value directly and then
			manually calls `),ye=s("code"),Ha=t(".update()"),Na=t(", which seems like an antipattern"),Pa=i(),Ce=s("pre"),Ta=t(`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),Ra=i(),J=s("h2"),La=t("F. "),Oe=s("code"),qa=t("fastMutable"),ja=t(" store"),Va=i(),L=s("section"),A=s("div"),De=s("span"),ut=t(xe),Wa=t(`
			\u2190 works because it's a `),ke=s("code"),Ba=t("fastMutable"),Fa=t(` store, which compared to
			`),Ae=s("code"),Ga=t("mutable"),Ua=t(` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),Ka=i(),z=s("pre"),Qa=t("fastMutableMap.update(($v) => "),Ja=t(Rs),za=t(`
	$v.set('a', $v.get('a') + 1);
});`),Xa=i(),Ya=s("hr"),Za=i(),Ie=s("h2"),xa=t("notes:"),es=i(),_=s("ul"),$e=s("li"),ts=t("Why care about the immutable option? See this example: "),Se=s("a"),as=t("https://svelte.dev/examples/immutable-data"),ss=i(),et=s("li"),ls=t(`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),os=i(),tt=s("li"),rs=t(`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),ns=i(),q=s("li"),cs=t("Is "),He=s("code"),ds=t("fastMutable"),us=t(`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=s("code"),is=t("mutable"),hs=t(" implementation be preferred in all cases?"),bs=i(),j=s("li"),vs=t("Are there bettes names than "),Pe=s("code"),ps=t("mutable"),ms=t(" and "),Te=s("code"),fs=t("fastMutable"),Es=t("?"),_s=i(),V=s("li"),gs=t("Add a "),Re=s("code"),ws=t("set"),Ms=t(" store method? Probably useful for "),Le=s("code"),ys=t("bind:"),Cs=t(" usage in some cases\n			and less code than `update` to replace references."),Os=i(),Ds=s("hr"),ks=i(),qe=s("footer"),je=s("a"),As=t("public domain source code on GitHub"),this.h()},l(v){n=l(v,"MAIN",{class:!0});var c=r(n);p=l(c,"HEADER",{});var it=r(p);m=l(it,"H1",{class:!0});var qs=r(m);f=l(qs,"A",{href:!0});var js=r(f);y=a(js,"svelte-mutable-store"),js.forEach(o),qs.forEach(o),C=h(it),E=l(it,"BLOCKQUOTE",{});var at=r(E);ae=a(at,"using mutable values in Svelte stores with the "),g=l(at,"CODE",{class:!0});var Vs=r(g);W=a(Vs,"immutable"),Vs.forEach(o),X=a(at,` compiler flag.
			`),I=l(at,"A",{href:!0});var Ws=r(I);Y=a(Ws,"learn more on GitHub"),Ws.forEach(o),at.forEach(o),it.forEach(o),Z=h(c),O=l(c,"BUTTON",{class:!0});var Bs=r(O);st=a(Bs,"click me to make number++ go up"),Bs.forEach(o),lt=h(c),b=l(c,"H2",{class:!0});var ht=r(b);It=a(ht,"A. "),se=l(ht,"CODE",{class:!0});var Fs=r(se);$t=a(Fs,"writable"),Fs.forEach(o),St=a(ht," store (broken! D:)"),ht.forEach(o),Ht=h(c),$=l(c,"SECTION",{});var bt=r($);S=l(bt,"DIV",{});var Ve=r(S);le=l(Ve,"SPAN",{class:!0});var Gs=r(le);ot=a(Gs,Je),Gs.forEach(o),Nt=a(Ve,`
			\u2190 fails to update as a `),oe=l(Ve,"CODE",{class:!0});var Us=r(oe);Pt=a(Us,"writable"),Us.forEach(o),Tt=a(Ve," store because "),B=l(Ve,"CODE",{class:!0});var vt=r(B);Rt=a(vt,"immutable="),Lt=a(vt,Ns),qt=a(vt,"true}"),vt.forEach(o),Ve.forEach(o),jt=h(bt),re=l(bt,"PRE",{class:!0});var Ks=r(re);Vt=a(Ks,`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Ks.forEach(o),bt.forEach(o),Wt=h(c),F=l(c,"H2",{class:!0});var pt=r(F);Bt=a(pt,"B. cloned "),ne=l(pt,"CODE",{class:!0});var Qs=r(ne);Ft=a(Qs,"writable"),Qs.forEach(o),Gt=a(pt," store"),pt.forEach(o),Ut=h(c),H=l(c,"SECTION",{});var mt=r(H);ce=l(mt,"DIV",{});var $s=r(ce);de=l($s,"SPAN",{class:!0});var Js=r(de);rt=a(Js,ze),Js.forEach(o),Kt=a($s,`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),$s.forEach(o),Qt=h(mt),ue=l(mt,"PRE",{class:!0});var zs=r(ue);Jt=a(zs,`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),zs.forEach(o),mt.forEach(o),zt=h(c),x=l(c,"BLOCKQUOTE",{});var ft=r(x);Xt=a(ft,"in the examples below, notice that you need to access "),ie=l(ft,"CODE",{class:!0});var Xs=r(ie);Yt=a(Xs,".value"),Xs.forEach(o),Zt=a(ft," for reads, unlike above"),ft.forEach(o),xt=h(c),D=l(c,"H2",{class:!0});var We=r(D);ea=a(We,"C. "),he=l(We,"CODE",{class:!0});var Ys=r(he);ta=a(Ys,"derived"),Ys.forEach(o),aa=a(We," from "),be=l(We,"CODE",{class:!0});var Zs=r(be);sa=a(Zs,"writable"),Zs.forEach(o),la=a(We," store"),We.forEach(o),oa=h(c),N=l(c,"SECTION",{});var Et=r(N);ve=l(Et,"DIV",{});var Ss=r(ve);pe=l(Ss,"SPAN",{class:!0});var xs=r(pe);nt=a(xs,Xe),xs.forEach(o),ra=a(Ss,`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),Ss.forEach(o),na=h(Et),G=l(Et,"PRE",{class:!0});var _t=r(G);ca=a(_t,"const derivedWritableMap = derived(writableMap, ($v) => ("),da=a(_t,Ps),ua=a(_t,"value: $v}));"),_t.forEach(o),Et.forEach(o),ia=h(c),U=l(c,"H2",{class:!0});var gt=r(U);ha=a(gt,"D. "),me=l(gt,"CODE",{class:!0});var el=r(me);ba=a(el,"mutable"),el.forEach(o),va=a(gt," store"),gt.forEach(o),pa=h(c),P=l(c,"SECTION",{});var wt=r(P);T=l(wt,"DIV",{});var Be=r(T);fe=l(Be,"SPAN",{class:!0});var tl=r(fe);ct=a(tl,Ye),tl.forEach(o),ma=a(Be,`
			\u2190 works because it's a `),Ee=l(Be,"CODE",{class:!0});var al=r(Ee);fa=a(al,"mutable"),al.forEach(o),Ea=a(Be,` store; doesn't clone the map; however notice that
			you need to access `),_e=l(Be,"CODE",{class:!0});var sl=r(_e);_a=a(sl,".value"),sl.forEach(o),Be.forEach(o),ga=h(wt),K=l(wt,"PRE",{class:!0});var Mt=r(K);wa=a(Mt,"mutableMap.update(($v) => "),Ma=a(Mt,Ts),ya=a(Mt,`
	$v.set('a', $v.get('a') + 1);
});`),Mt.forEach(o),wt.forEach(o),Ca=h(c),Q=l(c,"H2",{class:!0});var yt=r(Q);Oa=a(yt,"E. "),ge=l(yt,"CODE",{class:!0});var ll=r(ge);Da=a(ll,"mutable"),ll.forEach(o),ka=a(yt," store antipattern"),yt.forEach(o),Aa=h(c),R=l(c,"SECTION",{});var Ct=r(R);k=l(Ct,"DIV",{});var ee=r(k);we=l(ee,"SPAN",{class:!0});var ol=r(we);dt=a(ol,Ze),ol.forEach(o),Ia=a(ee,`
			\u2190 works because it's a `),Me=l(ee,"CODE",{class:!0});var rl=r(Me);$a=a(rl,"mutable"),rl.forEach(o),Sa=a(ee,` store, but mutates the value directly and then
			manually calls `),ye=l(ee,"CODE",{class:!0});var nl=r(ye);Ha=a(nl,".update()"),nl.forEach(o),Na=a(ee,", which seems like an antipattern"),ee.forEach(o),Pa=h(Ct),Ce=l(Ct,"PRE",{class:!0});var cl=r(Ce);Ta=a(cl,`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),cl.forEach(o),Ct.forEach(o),Ra=h(c),J=l(c,"H2",{class:!0});var Ot=r(J);La=a(Ot,"F. "),Oe=l(Ot,"CODE",{class:!0});var dl=r(Oe);qa=a(dl,"fastMutable"),dl.forEach(o),ja=a(Ot," store"),Ot.forEach(o),Va=h(c),L=l(c,"SECTION",{});var Dt=r(L);A=l(Dt,"DIV",{});var te=r(A);De=l(te,"SPAN",{class:!0});var ul=r(De);ut=a(ul,xe),ul.forEach(o),Wa=a(te,`
			\u2190 works because it's a `),ke=l(te,"CODE",{class:!0});var il=r(ke);Ba=a(il,"fastMutable"),il.forEach(o),Fa=a(te,` store, which compared to
			`),Ae=l(te,"CODE",{class:!0});var hl=r(Ae);Ga=a(hl,"mutable"),hl.forEach(o),Ua=a(te,` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),te.forEach(o),Ka=h(Dt),z=l(Dt,"PRE",{class:!0});var kt=r(z);Qa=a(kt,"fastMutableMap.update(($v) => "),Ja=a(kt,Rs),za=a(kt,`
	$v.set('a', $v.get('a') + 1);
});`),kt.forEach(o),Dt.forEach(o),Xa=h(c),Ya=l(c,"HR",{}),Za=h(c),Ie=l(c,"H2",{class:!0});var bl=r(Ie);xa=a(bl,"notes:"),bl.forEach(o),es=h(c),_=l(c,"UL",{});var w=r(_);$e=l(w,"LI",{});var Hs=r($e);ts=a(Hs,"Why care about the immutable option? See this example: "),Se=l(Hs,"A",{href:!0});var vl=r(Se);as=a(vl,"https://svelte.dev/examples/immutable-data"),vl.forEach(o),Hs.forEach(o),ss=h(w),et=l(w,"LI",{});var pl=r(et);ls=a(pl,`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),pl.forEach(o),os=h(w),tt=l(w,"LI",{});var ml=r(tt);rs=a(ml,`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),ml.forEach(o),ns=h(w),q=l(w,"LI",{});var Fe=r(q);cs=a(Fe,"Is "),He=l(Fe,"CODE",{class:!0});var fl=r(He);ds=a(fl,"fastMutable"),fl.forEach(o),us=a(Fe,`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=l(Fe,"CODE",{class:!0});var El=r(Ne);is=a(El,"mutable"),El.forEach(o),hs=a(Fe," implementation be preferred in all cases?"),Fe.forEach(o),bs=h(w),j=l(w,"LI",{});var Ge=r(j);vs=a(Ge,"Are there bettes names than "),Pe=l(Ge,"CODE",{class:!0});var _l=r(Pe);ps=a(_l,"mutable"),_l.forEach(o),ms=a(Ge," and "),Te=l(Ge,"CODE",{class:!0});var gl=r(Te);fs=a(gl,"fastMutable"),gl.forEach(o),Es=a(Ge,"?"),Ge.forEach(o),_s=h(w),V=l(w,"LI",{});var Ue=r(V);gs=a(Ue,"Add a "),Re=l(Ue,"CODE",{class:!0});var wl=r(Re);ws=a(wl,"set"),wl.forEach(o),Ms=a(Ue," store method? Probably useful for "),Le=l(Ue,"CODE",{class:!0});var Ml=r(Le);ys=a(Ml,"bind:"),Ml.forEach(o),Cs=a(Ue," usage in some cases\n			and less code than `update` to replace references."),Ue.forEach(o),w.forEach(o),Os=h(c),Ds=l(c,"HR",{}),ks=h(c),qe=l(c,"FOOTER",{class:!0});var yl=r(qe);je=l(yl,"A",{href:!0});var Cl=r(je);As=a(Cl,"public domain source code on GitHub"),Cl.forEach(o),yl.forEach(o),c.forEach(o),this.h()},h(){d(f,"href","https://github.com/spiderspace/svelte-mutable-store"),d(m,"class","svelte-1hmclby"),d(g,"class","svelte-1hmclby"),d(I,"href","https://github.com/spiderspace/svelte-mutable-store"),d(O,"class","svelte-1hmclby"),d(se,"class","svelte-1hmclby"),d(b,"class","svelte-1hmclby"),d(le,"class","count svelte-1hmclby"),d(oe,"class","svelte-1hmclby"),d(B,"class","svelte-1hmclby"),d(re,"class","panel-inset svelte-1hmclby"),M($,"--hue",u[12](u[0].get("a")),!1),d(ne,"class","svelte-1hmclby"),d(F,"class","svelte-1hmclby"),d(de,"class","count svelte-1hmclby"),d(ue,"class","panel-inset svelte-1hmclby"),M(H,"--hue",u[12](u[1].get("a")),!1),d(ie,"class","svelte-1hmclby"),d(he,"class","svelte-1hmclby"),d(be,"class","svelte-1hmclby"),d(D,"class","svelte-1hmclby"),d(pe,"class","count svelte-1hmclby"),d(G,"class","panel-inset svelte-1hmclby"),M(N,"--hue",u[12](u[3].value.get("a")),!1),d(me,"class","svelte-1hmclby"),d(U,"class","svelte-1hmclby"),d(fe,"class","count svelte-1hmclby"),d(Ee,"class","svelte-1hmclby"),d(_e,"class","svelte-1hmclby"),d(K,"class","panel-inset svelte-1hmclby"),M(P,"--hue",u[12](u[4].value.get("a")),!1),d(ge,"class","svelte-1hmclby"),d(Q,"class","svelte-1hmclby"),d(we,"class","count svelte-1hmclby"),d(Me,"class","svelte-1hmclby"),d(ye,"class","svelte-1hmclby"),d(Ce,"class","panel-inset svelte-1hmclby"),M(R,"--hue",u[12](u[2].value.get("a")),!1),d(Oe,"class","svelte-1hmclby"),d(J,"class","svelte-1hmclby"),d(De,"class","count svelte-1hmclby"),d(ke,"class","svelte-1hmclby"),d(Ae,"class","svelte-1hmclby"),d(z,"class","panel-inset svelte-1hmclby"),M(L,"--hue",u[12](u[5].value.get("a")),!1),d(Ie,"class","svelte-1hmclby"),d(Se,"href","https://svelte.dev/examples/immutable-data"),d(He,"class","svelte-1hmclby"),d(Ne,"class","svelte-1hmclby"),d(Pe,"class","svelte-1hmclby"),d(Te,"class","svelte-1hmclby"),d(Re,"class","svelte-1hmclby"),d(Le,"class","svelte-1hmclby"),d(je,"href","https://github.com/spiderspace/svelte-mutable-store"),d(qe,"class","svelte-1hmclby"),d(n,"class","markup svelte-1hmclby")},m(v,c){$l(v,n,c),e(n,p),e(p,m),e(m,f),e(f,y),e(p,C),e(p,E),e(E,ae),e(E,g),e(g,W),e(E,X),e(E,I),e(I,Y),e(n,Z),e(n,O),e(O,st),e(n,lt),e(n,b),e(b,It),e(b,se),e(se,$t),e(b,St),e(n,Ht),e(n,$),e($,S),e(S,le),e(le,ot),e(S,Nt),e(S,oe),e(oe,Pt),e(S,Tt),e(S,B),e(B,Rt),e(B,Lt),e(B,qt),e($,jt),e($,re),e(re,Vt),e(n,Wt),e(n,F),e(F,Bt),e(F,ne),e(ne,Ft),e(F,Gt),e(n,Ut),e(n,H),e(H,ce),e(ce,de),e(de,rt),e(ce,Kt),e(H,Qt),e(H,ue),e(ue,Jt),e(n,zt),e(n,x),e(x,Xt),e(x,ie),e(ie,Yt),e(x,Zt),e(n,xt),e(n,D),e(D,ea),e(D,he),e(he,ta),e(D,aa),e(D,be),e(be,sa),e(D,la),e(n,oa),e(n,N),e(N,ve),e(ve,pe),e(pe,nt),e(ve,ra),e(N,na),e(N,G),e(G,ca),e(G,da),e(G,ua),e(n,ia),e(n,U),e(U,ha),e(U,me),e(me,ba),e(U,va),e(n,pa),e(n,P),e(P,T),e(T,fe),e(fe,ct),e(T,ma),e(T,Ee),e(Ee,fa),e(T,Ea),e(T,_e),e(_e,_a),e(P,ga),e(P,K),e(K,wa),e(K,Ma),e(K,ya),e(n,Ca),e(n,Q),e(Q,Oa),e(Q,ge),e(ge,Da),e(Q,ka),e(n,Aa),e(n,R),e(R,k),e(k,we),e(we,dt),e(k,Ia),e(k,Me),e(Me,$a),e(k,Sa),e(k,ye),e(ye,Ha),e(k,Na),e(R,Pa),e(R,Ce),e(Ce,Ta),e(n,Ra),e(n,J),e(J,La),e(J,Oe),e(Oe,qa),e(J,ja),e(n,Va),e(n,L),e(L,A),e(A,De),e(De,ut),e(A,Wa),e(A,ke),e(ke,Ba),e(A,Fa),e(A,Ae),e(Ae,Ga),e(A,Ua),e(L,Ka),e(L,z),e(z,Qa),e(z,Ja),e(z,za),e(n,Xa),e(n,Ya),e(n,Za),e(n,Ie),e(Ie,xa),e(n,es),e(n,_),e(_,$e),e($e,ts),e($e,Se),e(Se,as),e(_,ss),e(_,et),e(et,ls),e(_,os),e(_,tt),e(tt,rs),e(_,ns),e(_,q),e(q,cs),e(q,He),e(He,ds),e(q,us),e(q,Ne),e(Ne,is),e(q,hs),e(_,bs),e(_,j),e(j,vs),e(j,Pe),e(Pe,ps),e(j,ms),e(j,Te),e(Te,fs),e(j,Es),e(_,_s),e(_,V),e(V,gs),e(V,Re),e(Re,ws),e(V,Ms),e(V,Le),e(Le,ys),e(V,Cs),e(n,Os),e(n,Ds),e(n,ks),e(n,qe),e(qe,je),e(je,As),Is||(Ls=Sl(O,"click",u[13]),Is=!0)},p(v,[c]){c&1&&Je!==(Je=v[0].get("a")+"")&&Ke(ot,Je),c&1&&M($,"--hue",v[12](v[0].get("a")),!1),c&2&&ze!==(ze=v[1].get("a")+"")&&Ke(rt,ze),c&2&&M(H,"--hue",v[12](v[1].get("a")),!1),c&8&&Xe!==(Xe=v[3].value.get("a")+"")&&Ke(nt,Xe),c&8&&M(N,"--hue",v[12](v[3].value.get("a")),!1),c&16&&Ye!==(Ye=v[4].value.get("a")+"")&&Ke(ct,Ye),c&16&&M(P,"--hue",v[12](v[4].value.get("a")),!1),c&4&&Ze!==(Ze=v[2].value.get("a")+"")&&Ke(dt,Ze),c&4&&M(R,"--hue",v[12](v[2].value.get("a")),!1),c&32&&xe!==(xe=v[5].value.get("a")+"")&&Ke(ut,xe),c&32&&M(L,"--hue",v[12](v[5].value.get("a")),!1)},i:Ol,o:Ol,d(v){v&&o(n),Is=!1,Ls()}}}function Rl(u,n,p){let m,f,y,C,E,ae;const g=[["a",1]],W=At(new Map(g));Qe(u,W,b=>p(0,m=b));const X=At(new Map(g));Qe(u,X,b=>p(1,f=b));const I=Hl(W,b=>({value:b}));Qe(u,I,b=>p(3,C=b));const Y=Dl(new Map(g));Qe(u,Y,b=>p(4,E=b));const Z=Dl(new Map(g));Qe(u,Z,b=>p(2,y=b));const O=Pl(new Map(g));return Qe(u,O,b=>p(5,ae=b)),[m,f,y,C,E,ae,W,X,I,Y,Z,O,b=>b*37+"",()=>{m.set("a",m.get("a")+1),W.set(m),f.set("a",f.get("a")+1),Nl(X,f=new Map(f),f),Y.update(b=>{b.set("a",b.get("a")+1)}),y.value.set("a",y.value.get("a")+1),Z.update(),O.update(b=>{b.set("a",b.get("a")+1)})}]}class ql extends kl{constructor(n){super();Al(this,n,Rl,Tl,Il,{})}}export{ql as default};
