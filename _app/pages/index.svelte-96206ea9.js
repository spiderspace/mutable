import{C as Lt,S as ao,i as lo,n as so,e as l,t,j as i,c as s,a as r,g as a,d as o,m as h,b as u,K as O,f as oo,F as e,L as ro,s as tt,J as eo,M as at,N as no,O as co}from"../chunks/vendor-7ffe92ef.js";const to=d=>{const{subscribe:n,set:b}=Lt({value:d});return{subscribe:n,update:f=>{if(f){const m=f(d);m!==void 0&&m!==d&&(d=m)}b({value:d})},set:f=>{d=f,b({value:d})}}},uo=d=>{let n=!1;const b={value:d},f={value:d},{subscribe:m,set:k}=Lt(b);return{subscribe:m,update:$=>{if($){const E=$(d);E!==void 0&&E!==d&&(d=b.value=f.value=E)}k((n=!n)?f:b)},set:$=>{d=b.value=f.value=$,k((n=!n)?f:b)}}};function io(d){let n,b,f,m,k,$,E,ne,_,B,X,A,Y,Z,x,it,ht,p,qt,ce,Wt,Bt,Ft,I,S,ue,lt=d[0].get("a")+"",pt,Gt,de,Ut,Jt,F,Kt,ss="{",Qt,zt,Vt,ie,Xt,Yt,G,Zt,he,ea,ta,aa,H,pe,ve,st=d[1].get("a")+"",vt,la,sa,be,oa,ra,ee,na,fe,ca,ua,da,y,ia,me,ha,pa,ge,va,ba,fa,N,Ee,we,ot=d[3].value.get("a")+"",bt,ma,ga,U,Ea,os="{",wa,_a,Ma,J,Ca,_e,Oa,ka,$a,R,T,Me,rt=d[4].value.get("a")+"",ft,xa,Ce,ya,Da,Oe,Pa,Aa,K,Ia,rs="{",Sa,Ha,Na,Q,Ra,ke,Ta,ja,La,g,D,$e,nt=d[2].value.get("a")+"",mt,qa,xe,Wa,Ba,ye,Fa,Ga,Ua,De,Ja,Ka,te,Qa,Pe,za,Va,Xa,Ae,Ya,Za,ae,el,Ie,tl,al,ll,Se,sl,ol,z,rl,He,nl,cl,ul,j,P,Ne,ct=d[5].value.get("a")+"",gt,dl,Re,il,hl,Te,pl,vl,bl,V,fl,ns="{",ml,gl,El,wl,_l,je,Ml,Cl,w,le,Ol,Le,kl,$l,xl,ut,yl,Dl,se,Pl,qe,Al,Il,Sl,L,Hl,We,Nl,Rl,Be,Tl,jl,Ll,q,ql,Fe,Wl,Bl,Ge,Fl,Gl,Ul,W,Jl,Ue,Kl,Ql,Je,zl,Vl,Xl,Yl,Zl,Ke,Qe,es,ts,cs;return{c(){n=l("main"),b=l("header"),f=l("h1"),m=l("a"),k=t("svelte-mutable"),$=i(),E=l("blockquote"),ne=t("using mutable values in Svelte stores with the "),_=l("code"),B=t("immutable"),X=t(` compiler flag.
			`),A=l("a"),Y=t("learn more on GitHub"),Z=i(),x=l("button"),it=t("click me to make number++ go up"),ht=i(),p=l("h2"),qt=t("A. "),ce=l("code"),Wt=t("writable"),Bt=t(" store (broken! D:)"),Ft=i(),I=l("section"),S=l("p"),ue=l("span"),pt=t(lt),Gt=t(`
			\u2190 fails to update as a `),de=l("code"),Ut=t("writable"),Jt=t(" store because "),F=l("code"),Kt=t("immutable="),Qt=t(ss),zt=t("true}"),Vt=i(),ie=l("pre"),Xt=t(`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Yt=i(),G=l("h2"),Zt=t("B. cloned "),he=l("code"),ea=t("writable"),ta=t(" store"),aa=i(),H=l("section"),pe=l("p"),ve=l("span"),vt=t(st),la=t(`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),sa=i(),be=l("pre"),oa=t(`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),ra=i(),ee=l("blockquote"),na=t("in the examples below, notice that you need to access "),fe=l("code"),ca=t(".value"),ua=t(" for reads, unlike above"),da=i(),y=l("h2"),ia=t("C. "),me=l("code"),ha=t("derived"),pa=t(" from "),ge=l("code"),va=t("writable"),ba=t(" store"),fa=i(),N=l("section"),Ee=l("p"),we=l("span"),bt=t(ot),ma=t(`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),ga=i(),U=l("pre"),Ea=t("const derivedWritableMap = derived(writableMap, ($v) => ("),wa=t(os),_a=t("value: $v}));"),Ma=i(),J=l("h2"),Ca=t("D. "),_e=l("code"),Oa=t("mutable"),ka=t(" store"),$a=i(),R=l("section"),T=l("p"),Me=l("span"),ft=t(rt),xa=t(`
			\u2190 works because it's a `),Ce=l("code"),ya=t("mutable"),Da=t(` store; doesn't clone the map; however notice that
			you need to access `),Oe=l("code"),Pa=t(".value"),Aa=i(),K=l("pre"),Ia=t("mutableMap.update(($v) => "),Sa=t(rs),Ha=t(`
	$v.set('a', $v.get('a') + 1);
});`),Na=i(),Q=l("h2"),Ra=t("E. "),ke=l("code"),Ta=t("mutable"),ja=t(" store with manual update or set"),La=i(),g=l("section"),D=l("p"),$e=l("span"),mt=t(nt),qa=t(`
			\u2190 works because it's a `),xe=l("code"),Wa=t("mutable"),Ba=t(` store, but mutates the value directly and then
			manually calls `),ye=l("code"),Fa=t(".update()"),Ga=t(", which seems like an antipattern"),Ua=i(),De=l("pre"),Ja=t(`$mutableMapManual.value.set('a', $mutableMapManual.value.get('a') + 1);
mutableMapManual.update();`),Ka=i(),te=l("p"),Qa=t("an alternative using the store's "),Pe=l("code"),za=t("set"),Va=t(" method:"),Xa=i(),Ae=l("pre"),Ya=t(`$mutableMapManual.value.set('a', $mutableMapManual.value.get('a') + 1);
$mutableMapManual = $mutableMapManual.value;`),Za=i(),ae=l("p"),el=t("and you can set a new value if you need to, but if this is all you need, prefer a "),Ie=l("code"),tl=t("writable"),al=t(":"),ll=i(),Se=l("pre"),sl=t(`$mutableMapManual = new Map([/*...*/]);
mutableMapManual.update(() => new Map([/*...*/]));`),ol=i(),z=l("h2"),rl=t("F. "),He=l("code"),nl=t("fastMutable"),cl=t(" store"),ul=i(),j=l("section"),P=l("p"),Ne=l("span"),gt=t(ct),dl=t(`
			\u2190 works because it's a `),Re=l("code"),il=t("fastMutable"),hl=t(` store, which compared to
			`),Te=l("code"),pl=t("mutable"),vl=t(` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),bl=i(),V=l("pre"),fl=t("fastMutableMap.update(($v) => "),ml=t(ns),gl=t(`
	$v.set('a', $v.get('a') + 1);
});`),El=i(),wl=l("hr"),_l=i(),je=l("h2"),Ml=t("notes:"),Cl=i(),w=l("ul"),le=l("li"),Ol=t("Why care about the immutable option? Mainly performance. See "),Le=l("a"),kl=t("the official example"),$l=t("."),xl=i(),ut=l("li"),yl=t(`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),Dl=i(),se=l("li"),Pl=t(`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something? Maybe lightweight immutable maps/arrays/sets with structural sharing and an API
			that jive with their JS counterparts? (`),qe=l("a"),Al=t("Immutable.js"),Il=t(` v4 is 65k minified and has patterns that diverge from the builtin collections; which in some
			cases might be worth paying for)`),Sl=i(),L=l("li"),Hl=t("Is "),We=l("code"),Nl=t("fastMutable"),Rl=t(`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Be=l("code"),Tl=t("mutable"),jl=t(" implementation be preferred in all cases?"),Ll=i(),q=l("li"),ql=t("Are there better names than "),Fe=l("code"),Wl=t("mutable"),Bl=t(" and "),Ge=l("code"),Fl=t("fastMutable"),Gl=t("?"),Ul=i(),W=l("li"),Jl=t("Add a "),Ue=l("code"),Kl=t("set"),Ql=t(" store method? Probably useful for "),Je=l("code"),zl=t("bind:"),Vl=t(" usage in some cases\n			and less code than `update` to replace references."),Xl=i(),Yl=l("hr"),Zl=i(),Ke=l("footer"),Qe=l("a"),es=t("public domain source code on GitHub"),this.h()},l(v){n=s(v,"MAIN",{class:!0});var c=r(n);b=s(c,"HEADER",{});var Et=r(b);f=s(Et,"H1",{class:!0});var us=r(f);m=s(us,"A",{href:!0});var ds=r(m);k=a(ds,"svelte-mutable"),ds.forEach(o),us.forEach(o),$=h(Et),E=s(Et,"BLOCKQUOTE",{});var dt=r(E);ne=a(dt,"using mutable values in Svelte stores with the "),_=s(dt,"CODE",{class:!0});var is=r(_);B=a(is,"immutable"),is.forEach(o),X=a(dt,` compiler flag.
			`),A=s(dt,"A",{href:!0});var hs=r(A);Y=a(hs,"learn more on GitHub"),hs.forEach(o),dt.forEach(o),Et.forEach(o),Z=h(c),x=s(c,"BUTTON",{class:!0});var ps=r(x);it=a(ps,"click me to make number++ go up"),ps.forEach(o),ht=h(c),p=s(c,"H2",{class:!0});var wt=r(p);qt=a(wt,"A. "),ce=s(wt,"CODE",{class:!0});var vs=r(ce);Wt=a(vs,"writable"),vs.forEach(o),Bt=a(wt," store (broken! D:)"),wt.forEach(o),Ft=h(c),I=s(c,"SECTION",{});var _t=r(I);S=s(_t,"P",{});var ze=r(S);ue=s(ze,"SPAN",{class:!0});var bs=r(ue);pt=a(bs,lt),bs.forEach(o),Gt=a(ze,`
			\u2190 fails to update as a `),de=s(ze,"CODE",{class:!0});var fs=r(de);Ut=a(fs,"writable"),fs.forEach(o),Jt=a(ze," store because "),F=s(ze,"CODE",{class:!0});var Mt=r(F);Kt=a(Mt,"immutable="),Qt=a(Mt,ss),zt=a(Mt,"true}"),Mt.forEach(o),ze.forEach(o),Vt=h(_t),ie=s(_t,"PRE",{class:!0});var ms=r(ie);Xt=a(ms,`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),ms.forEach(o),_t.forEach(o),Yt=h(c),G=s(c,"H2",{class:!0});var Ct=r(G);Zt=a(Ct,"B. cloned "),he=s(Ct,"CODE",{class:!0});var gs=r(he);ea=a(gs,"writable"),gs.forEach(o),ta=a(Ct," store"),Ct.forEach(o),aa=h(c),H=s(c,"SECTION",{});var Ot=r(H);pe=s(Ot,"P",{});var as=r(pe);ve=s(as,"SPAN",{class:!0});var Es=r(ve);vt=a(Es,st),Es.forEach(o),la=a(as,`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),as.forEach(o),sa=h(Ot),be=s(Ot,"PRE",{class:!0});var ws=r(be);oa=a(ws,`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),ws.forEach(o),Ot.forEach(o),ra=h(c),ee=s(c,"BLOCKQUOTE",{});var kt=r(ee);na=a(kt,"in the examples below, notice that you need to access "),fe=s(kt,"CODE",{class:!0});var _s=r(fe);ca=a(_s,".value"),_s.forEach(o),ua=a(kt," for reads, unlike above"),kt.forEach(o),da=h(c),y=s(c,"H2",{class:!0});var Ve=r(y);ia=a(Ve,"C. "),me=s(Ve,"CODE",{class:!0});var Ms=r(me);ha=a(Ms,"derived"),Ms.forEach(o),pa=a(Ve," from "),ge=s(Ve,"CODE",{class:!0});var Cs=r(ge);va=a(Cs,"writable"),Cs.forEach(o),ba=a(Ve," store"),Ve.forEach(o),fa=h(c),N=s(c,"SECTION",{});var $t=r(N);Ee=s($t,"P",{});var ls=r(Ee);we=s(ls,"SPAN",{class:!0});var Os=r(we);bt=a(Os,ot),Os.forEach(o),ma=a(ls,`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),ls.forEach(o),ga=h($t),U=s($t,"PRE",{class:!0});var xt=r(U);Ea=a(xt,"const derivedWritableMap = derived(writableMap, ($v) => ("),wa=a(xt,os),_a=a(xt,"value: $v}));"),xt.forEach(o),$t.forEach(o),Ma=h(c),J=s(c,"H2",{class:!0});var yt=r(J);Ca=a(yt,"D. "),_e=s(yt,"CODE",{class:!0});var ks=r(_e);Oa=a(ks,"mutable"),ks.forEach(o),ka=a(yt," store"),yt.forEach(o),$a=h(c),R=s(c,"SECTION",{});var Dt=r(R);T=s(Dt,"P",{});var Xe=r(T);Me=s(Xe,"SPAN",{class:!0});var $s=r(Me);ft=a($s,rt),$s.forEach(o),xa=a(Xe,`
			\u2190 works because it's a `),Ce=s(Xe,"CODE",{class:!0});var xs=r(Ce);ya=a(xs,"mutable"),xs.forEach(o),Da=a(Xe,` store; doesn't clone the map; however notice that
			you need to access `),Oe=s(Xe,"CODE",{class:!0});var ys=r(Oe);Pa=a(ys,".value"),ys.forEach(o),Xe.forEach(o),Aa=h(Dt),K=s(Dt,"PRE",{class:!0});var Pt=r(K);Ia=a(Pt,"mutableMap.update(($v) => "),Sa=a(Pt,rs),Ha=a(Pt,`
	$v.set('a', $v.get('a') + 1);
});`),Pt.forEach(o),Dt.forEach(o),Na=h(c),Q=s(c,"H2",{class:!0});var At=r(Q);Ra=a(At,"E. "),ke=s(At,"CODE",{class:!0});var Ds=r(ke);Ta=a(Ds,"mutable"),Ds.forEach(o),ja=a(At," store with manual update or set"),At.forEach(o),La=h(c),g=s(c,"SECTION",{});var M=r(g);D=s(M,"P",{});var oe=r(D);$e=s(oe,"SPAN",{class:!0});var Ps=r($e);mt=a(Ps,nt),Ps.forEach(o),qa=a(oe,`
			\u2190 works because it's a `),xe=s(oe,"CODE",{class:!0});var As=r(xe);Wa=a(As,"mutable"),As.forEach(o),Ba=a(oe,` store, but mutates the value directly and then
			manually calls `),ye=s(oe,"CODE",{class:!0});var Is=r(ye);Fa=a(Is,".update()"),Is.forEach(o),Ga=a(oe,", which seems like an antipattern"),oe.forEach(o),Ua=h(M),De=s(M,"PRE",{class:!0});var Ss=r(De);Ja=a(Ss,`$mutableMapManual.value.set('a', $mutableMapManual.value.get('a') + 1);
mutableMapManual.update();`),Ss.forEach(o),Ka=h(M),te=s(M,"P",{});var It=r(te);Qa=a(It,"an alternative using the store's "),Pe=s(It,"CODE",{class:!0});var Hs=r(Pe);za=a(Hs,"set"),Hs.forEach(o),Va=a(It," method:"),It.forEach(o),Xa=h(M),Ae=s(M,"PRE",{class:!0});var Ns=r(Ae);Ya=a(Ns,`$mutableMapManual.value.set('a', $mutableMapManual.value.get('a') + 1);
$mutableMapManual = $mutableMapManual.value;`),Ns.forEach(o),Za=h(M),ae=s(M,"P",{});var St=r(ae);el=a(St,"and you can set a new value if you need to, but if this is all you need, prefer a "),Ie=s(St,"CODE",{class:!0});var Rs=r(Ie);tl=a(Rs,"writable"),Rs.forEach(o),al=a(St,":"),St.forEach(o),ll=h(M),Se=s(M,"PRE",{class:!0});var Ts=r(Se);sl=a(Ts,`$mutableMapManual = new Map([/*...*/]);
mutableMapManual.update(() => new Map([/*...*/]));`),Ts.forEach(o),M.forEach(o),ol=h(c),z=s(c,"H2",{class:!0});var Ht=r(z);rl=a(Ht,"F. "),He=s(Ht,"CODE",{class:!0});var js=r(He);nl=a(js,"fastMutable"),js.forEach(o),cl=a(Ht," store"),Ht.forEach(o),ul=h(c),j=s(c,"SECTION",{});var Nt=r(j);P=s(Nt,"P",{});var re=r(P);Ne=s(re,"SPAN",{class:!0});var Ls=r(Ne);gt=a(Ls,ct),Ls.forEach(o),dl=a(re,`
			\u2190 works because it's a `),Re=s(re,"CODE",{class:!0});var qs=r(Re);il=a(qs,"fastMutable"),qs.forEach(o),hl=a(re,` store, which compared to
			`),Te=s(re,"CODE",{class:!0});var Ws=r(Te);pl=a(Ws,"mutable"),Ws.forEach(o),vl=a(re,` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),re.forEach(o),bl=h(Nt),V=s(Nt,"PRE",{class:!0});var Rt=r(V);fl=a(Rt,"fastMutableMap.update(($v) => "),ml=a(Rt,ns),gl=a(Rt,`
	$v.set('a', $v.get('a') + 1);
});`),Rt.forEach(o),Nt.forEach(o),El=h(c),wl=s(c,"HR",{}),_l=h(c),je=s(c,"H2",{class:!0});var Bs=r(je);Ml=a(Bs,"notes:"),Bs.forEach(o),Cl=h(c),w=s(c,"UL",{});var C=r(w);le=s(C,"LI",{});var Tt=r(le);Ol=a(Tt,"Why care about the immutable option? Mainly performance. See "),Le=s(Tt,"A",{href:!0});var Fs=r(Le);kl=a(Fs,"the official example"),Fs.forEach(o),$l=a(Tt,"."),Tt.forEach(o),xl=h(C),ut=s(C,"LI",{});var Gs=r(ut);yl=a(Gs,`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),Gs.forEach(o),Dl=h(C),se=s(C,"LI",{});var jt=r(se);Pl=a(jt,`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something? Maybe lightweight immutable maps/arrays/sets with structural sharing and an API
			that jive with their JS counterparts? (`),qe=s(jt,"A",{href:!0});var Us=r(qe);Al=a(Us,"Immutable.js"),Us.forEach(o),Il=a(jt,` v4 is 65k minified and has patterns that diverge from the builtin collections; which in some
			cases might be worth paying for)`),jt.forEach(o),Sl=h(C),L=s(C,"LI",{});var Ye=r(L);Hl=a(Ye,"Is "),We=s(Ye,"CODE",{class:!0});var Js=r(We);Nl=a(Js,"fastMutable"),Js.forEach(o),Rl=a(Ye,`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Be=s(Ye,"CODE",{class:!0});var Ks=r(Be);Tl=a(Ks,"mutable"),Ks.forEach(o),jl=a(Ye," implementation be preferred in all cases?"),Ye.forEach(o),Ll=h(C),q=s(C,"LI",{});var Ze=r(q);ql=a(Ze,"Are there better names than "),Fe=s(Ze,"CODE",{class:!0});var Qs=r(Fe);Wl=a(Qs,"mutable"),Qs.forEach(o),Bl=a(Ze," and "),Ge=s(Ze,"CODE",{class:!0});var zs=r(Ge);Fl=a(zs,"fastMutable"),zs.forEach(o),Gl=a(Ze,"?"),Ze.forEach(o),Ul=h(C),W=s(C,"LI",{});var et=r(W);Jl=a(et,"Add a "),Ue=s(et,"CODE",{class:!0});var Vs=r(Ue);Kl=a(Vs,"set"),Vs.forEach(o),Ql=a(et," store method? Probably useful for "),Je=s(et,"CODE",{class:!0});var Xs=r(Je);zl=a(Xs,"bind:"),Xs.forEach(o),Vl=a(et," usage in some cases\n			and less code than `update` to replace references."),et.forEach(o),C.forEach(o),Xl=h(c),Yl=s(c,"HR",{}),Zl=h(c),Ke=s(c,"FOOTER",{class:!0});var Ys=r(Ke);Qe=s(Ys,"A",{href:!0});var Zs=r(Qe);es=a(Zs,"public domain source code on GitHub"),Zs.forEach(o),Ys.forEach(o),c.forEach(o),this.h()},h(){u(m,"href","https://github.com/spiderspace/svelte-mutable"),u(f,"class","svelte-og1xdl"),u(_,"class","svelte-og1xdl"),u(A,"href","https://github.com/spiderspace/svelte-mutable"),u(x,"class","svelte-og1xdl"),u(ce,"class","svelte-og1xdl"),u(p,"class","svelte-og1xdl"),u(ue,"class","count svelte-og1xdl"),u(de,"class","svelte-og1xdl"),u(F,"class","svelte-og1xdl"),u(ie,"class","panel-inset svelte-og1xdl"),O(I,"--hue",d[12](d[0].get("a")),!1),u(he,"class","svelte-og1xdl"),u(G,"class","svelte-og1xdl"),u(ve,"class","count svelte-og1xdl"),u(be,"class","panel-inset svelte-og1xdl"),O(H,"--hue",d[12](d[1].get("a")),!1),u(fe,"class","svelte-og1xdl"),u(me,"class","svelte-og1xdl"),u(ge,"class","svelte-og1xdl"),u(y,"class","svelte-og1xdl"),u(we,"class","count svelte-og1xdl"),u(U,"class","panel-inset svelte-og1xdl"),O(N,"--hue",d[12](d[3].value.get("a")),!1),u(_e,"class","svelte-og1xdl"),u(J,"class","svelte-og1xdl"),u(Me,"class","count svelte-og1xdl"),u(Ce,"class","svelte-og1xdl"),u(Oe,"class","svelte-og1xdl"),u(K,"class","panel-inset svelte-og1xdl"),O(R,"--hue",d[12](d[4].value.get("a")),!1),u(ke,"class","svelte-og1xdl"),u(Q,"class","svelte-og1xdl"),u($e,"class","count svelte-og1xdl"),u(xe,"class","svelte-og1xdl"),u(ye,"class","svelte-og1xdl"),u(De,"class","panel-inset svelte-og1xdl"),u(Pe,"class","svelte-og1xdl"),u(Ae,"class","panel-inset svelte-og1xdl"),u(Ie,"class","svelte-og1xdl"),u(Se,"class","panel-inset svelte-og1xdl"),O(g,"--hue",d[12](d[2].value.get("a")),!1),u(He,"class","svelte-og1xdl"),u(z,"class","svelte-og1xdl"),u(Ne,"class","count svelte-og1xdl"),u(Re,"class","svelte-og1xdl"),u(Te,"class","svelte-og1xdl"),u(V,"class","panel-inset svelte-og1xdl"),O(j,"--hue",d[12](d[5].value.get("a")),!1),u(je,"class","svelte-og1xdl"),u(Le,"href","https://svelte.dev/examples/immutable-data"),u(qe,"href","https://github.com/immutable-js/immutable-js"),u(We,"class","svelte-og1xdl"),u(Be,"class","svelte-og1xdl"),u(Fe,"class","svelte-og1xdl"),u(Ge,"class","svelte-og1xdl"),u(Ue,"class","svelte-og1xdl"),u(Je,"class","svelte-og1xdl"),u(Qe,"href","https://github.com/spiderspace/svelte-mutable"),u(Ke,"class","svelte-og1xdl"),u(n,"class","markup column svelte-og1xdl")},m(v,c){oo(v,n,c),e(n,b),e(b,f),e(f,m),e(m,k),e(b,$),e(b,E),e(E,ne),e(E,_),e(_,B),e(E,X),e(E,A),e(A,Y),e(n,Z),e(n,x),e(x,it),e(n,ht),e(n,p),e(p,qt),e(p,ce),e(ce,Wt),e(p,Bt),e(n,Ft),e(n,I),e(I,S),e(S,ue),e(ue,pt),e(S,Gt),e(S,de),e(de,Ut),e(S,Jt),e(S,F),e(F,Kt),e(F,Qt),e(F,zt),e(I,Vt),e(I,ie),e(ie,Xt),e(n,Yt),e(n,G),e(G,Zt),e(G,he),e(he,ea),e(G,ta),e(n,aa),e(n,H),e(H,pe),e(pe,ve),e(ve,vt),e(pe,la),e(H,sa),e(H,be),e(be,oa),e(n,ra),e(n,ee),e(ee,na),e(ee,fe),e(fe,ca),e(ee,ua),e(n,da),e(n,y),e(y,ia),e(y,me),e(me,ha),e(y,pa),e(y,ge),e(ge,va),e(y,ba),e(n,fa),e(n,N),e(N,Ee),e(Ee,we),e(we,bt),e(Ee,ma),e(N,ga),e(N,U),e(U,Ea),e(U,wa),e(U,_a),e(n,Ma),e(n,J),e(J,Ca),e(J,_e),e(_e,Oa),e(J,ka),e(n,$a),e(n,R),e(R,T),e(T,Me),e(Me,ft),e(T,xa),e(T,Ce),e(Ce,ya),e(T,Da),e(T,Oe),e(Oe,Pa),e(R,Aa),e(R,K),e(K,Ia),e(K,Sa),e(K,Ha),e(n,Na),e(n,Q),e(Q,Ra),e(Q,ke),e(ke,Ta),e(Q,ja),e(n,La),e(n,g),e(g,D),e(D,$e),e($e,mt),e(D,qa),e(D,xe),e(xe,Wa),e(D,Ba),e(D,ye),e(ye,Fa),e(D,Ga),e(g,Ua),e(g,De),e(De,Ja),e(g,Ka),e(g,te),e(te,Qa),e(te,Pe),e(Pe,za),e(te,Va),e(g,Xa),e(g,Ae),e(Ae,Ya),e(g,Za),e(g,ae),e(ae,el),e(ae,Ie),e(Ie,tl),e(ae,al),e(g,ll),e(g,Se),e(Se,sl),e(n,ol),e(n,z),e(z,rl),e(z,He),e(He,nl),e(z,cl),e(n,ul),e(n,j),e(j,P),e(P,Ne),e(Ne,gt),e(P,dl),e(P,Re),e(Re,il),e(P,hl),e(P,Te),e(Te,pl),e(P,vl),e(j,bl),e(j,V),e(V,fl),e(V,ml),e(V,gl),e(n,El),e(n,wl),e(n,_l),e(n,je),e(je,Ml),e(n,Cl),e(n,w),e(w,le),e(le,Ol),e(le,Le),e(Le,kl),e(le,$l),e(w,xl),e(w,ut),e(ut,yl),e(w,Dl),e(w,se),e(se,Pl),e(se,qe),e(qe,Al),e(se,Il),e(w,Sl),e(w,L),e(L,Hl),e(L,We),e(We,Nl),e(L,Rl),e(L,Be),e(Be,Tl),e(L,jl),e(w,Ll),e(w,q),e(q,ql),e(q,Fe),e(Fe,Wl),e(q,Bl),e(q,Ge),e(Ge,Fl),e(q,Gl),e(w,Ul),e(w,W),e(W,Jl),e(W,Ue),e(Ue,Kl),e(W,Ql),e(W,Je),e(Je,zl),e(W,Vl),e(n,Xl),e(n,Yl),e(n,Zl),e(n,Ke),e(Ke,Qe),e(Qe,es),ts||(cs=ro(x,"click",d[13]),ts=!0)},p(v,[c]){c&1&&lt!==(lt=v[0].get("a")+"")&&tt(pt,lt),c&1&&O(I,"--hue",v[12](v[0].get("a")),!1),c&2&&st!==(st=v[1].get("a")+"")&&tt(vt,st),c&2&&O(H,"--hue",v[12](v[1].get("a")),!1),c&8&&ot!==(ot=v[3].value.get("a")+"")&&tt(bt,ot),c&8&&O(N,"--hue",v[12](v[3].value.get("a")),!1),c&16&&rt!==(rt=v[4].value.get("a")+"")&&tt(ft,rt),c&16&&O(R,"--hue",v[12](v[4].value.get("a")),!1),c&4&&nt!==(nt=v[2].value.get("a")+"")&&tt(mt,nt),c&4&&O(g,"--hue",v[12](v[2].value.get("a")),!1),c&32&&ct!==(ct=v[5].value.get("a")+"")&&tt(gt,ct),c&32&&O(j,"--hue",v[12](v[5].value.get("a")),!1)},i:eo,o:eo,d(v){v&&o(n),ts=!1,cs()}}}function ho(d,n,b){let f,m,k,$,E,ne;const _=[["a",1]],B=Lt(new Map(_));at(d,B,p=>b(0,f=p));const X=Lt(new Map(_));at(d,X,p=>b(1,m=p));const A=no(B,p=>({value:p}));at(d,A,p=>b(3,$=p));const Y=to(new Map(_));at(d,Y,p=>b(4,E=p));const Z=to(new Map(_));at(d,Z,p=>b(2,k=p));const x=uo(new Map(_));return at(d,x,p=>b(5,ne=p)),[f,m,k,$,E,ne,B,X,A,Y,Z,x,p=>p*37+"",()=>{f.set("a",f.get("a")+1),B.set(f),m.set("a",m.get("a")+1),co(X,m=new Map(m),m),Y.update(p=>{p.set("a",p.get("a")+1)}),k.value.set("a",k.value.get("a")+1),Z.update(),x.update(p=>{p.set("a",p.get("a")+1)})}]}class vo extends ao{constructor(n){super();lo(this,n,ho,io,so,{})}}export{vo as default};
