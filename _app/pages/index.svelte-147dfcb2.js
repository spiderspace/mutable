import{C as It,S as Ol,i as Dl,n as kl,e as s,t,j as i,c as l,a as r,g as a,d as o,m as h,b as d,K as g,f as Al,F as e,L as Il,s as Ge,J as yl,M as Qe,N as $l,O as Sl}from"../chunks/vendor-7ffe92ef.js";const Cl=u=>{const{subscribe:c,set:p}=It({value:u});return{subscribe:c,update:m=>{if(m){const f=m(u);f!==void 0&&f!==u&&(u=f)}p({value:u})},set:m=>{u=m,p({value:u})}}},Hl=u=>{let c=!1;const p={value:u},m={value:u},{subscribe:f,set:M}=It(p);return{subscribe:f,update:E=>{if(E){const O=E(u);O!==void 0&&O!==u&&(u=p.value=m.value=O)}M((c=!c)?m:p)},set:E=>{u=p.value=m.value=E,M((c=!c)?m:p)}}};function Nl(u){let c,p,m,f,M,E,O,y,I,z="{",X,ae,Y,Z,C,at,st,v,$t,se,St,Ht,Nt,$,S,le,Je=u[0].get("a")+"",lt,Pt,oe,Tt,Rt,W,Lt,Ps="{",qt,jt,Vt,re,Wt,Bt,B,Ft,ce,Ut,Kt,Gt,H,ne,de,ze=u[1].get("a")+"",ot,Qt,Jt,ue,zt,Xt,x,Yt,ie,Zt,xt,ea,D,ta,he,aa,sa,ve,la,oa,ra,N,be,pe,Xe=u[3].value.get("a")+"",rt,ca,na,F,da,Ts="{",ua,ia,ha,U,va,me,ba,pa,ma,P,T,fe,Ye=u[4].value.get("a")+"",ct,fa,Ee,Ea,_a,_e,wa,ga,K,Ma,Rs="{",ya,Ca,Oa,G,Da,we,ka,Aa,Ia,R,k,ge,Ze=u[2].value.get("a")+"",nt,$a,Me,Sa,Ha,ye,Na,Pa,Ta,Ce,Ra,La,Q,qa,Oe,ja,Va,Wa,L,A,De,xe=u[5].value.get("a")+"",dt,Ba,ke,Fa,Ua,Ae,Ka,Ga,Qa,J,Ja,Ls="{",za,Xa,Ya,Za,xa,Ie,es,ts,_,$e,as,Se,ss,ls,et,os,rs,tt,cs,ns,q,ds,He,us,is,Ne,hs,vs,bs,j,ps,Pe,ms,fs,Te,Es,_s,ws,V,gs,Re,Ms,ys,Le,Cs,Os,Ds,ks,As,qe,je,Is,$s,qs;return{c(){c=s("main"),p=s("header"),m=s("h1"),f=t("svelte-mutable-store"),M=i(),E=s("blockquote"),O=t("how to efficiently wrap mutable values with the "),y=s("code"),I=t("immutable="),X=t(z),ae=t("true}"),Y=t(" compiler flag"),Z=i(),C=s("button"),at=t("click me to make number++ go up"),st=i(),v=s("h2"),$t=t("A. "),se=s("code"),St=t("writable"),Ht=t(" store (broken! D:)"),Nt=i(),$=s("section"),S=s("div"),le=s("span"),lt=t(Je),Pt=t(`
			\u2190 fails to update as a `),oe=s("code"),Tt=t("writable"),Rt=t(" store because "),W=s("code"),Lt=t("immutable="),qt=t(Ps),jt=t("true}"),Vt=i(),re=s("pre"),Wt=t(`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Bt=i(),B=s("h2"),Ft=t("B. cloned "),ce=s("code"),Ut=t("writable"),Kt=t(" store"),Gt=i(),H=s("section"),ne=s("div"),de=s("span"),ot=t(ze),Qt=t(`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),Jt=i(),ue=s("pre"),zt=t(`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),Xt=i(),x=s("blockquote"),Yt=t("in the examples below, notice that you need to access "),ie=s("code"),Zt=t(".value"),xt=t(" for reads, unlike above"),ea=i(),D=s("h2"),ta=t("C. "),he=s("code"),aa=t("derived"),sa=t(" from "),ve=s("code"),la=t("writable"),oa=t(" store"),ra=i(),N=s("section"),be=s("div"),pe=s("span"),rt=t(Xe),ca=t(`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),na=i(),F=s("pre"),da=t("const derivedWritableMap = derived(writableMap, ($v) => ("),ua=t(Ts),ia=t("value: $v}));"),ha=i(),U=s("h2"),va=t("D. "),me=s("code"),ba=t("mutable"),pa=t(" store"),ma=i(),P=s("section"),T=s("div"),fe=s("span"),ct=t(Ye),fa=t(`
			\u2190 works because it's a `),Ee=s("code"),Ea=t("mutable"),_a=t(` store; doesn't clone the map; however notice that
			you need to access `),_e=s("code"),wa=t(".value"),ga=i(),K=s("pre"),Ma=t("mutableMap.update(($v) => "),ya=t(Rs),Ca=t(`
	$v.set('a', $v.get('a') + 1);
});`),Oa=i(),G=s("h2"),Da=t("E. "),we=s("code"),ka=t("mutable"),Aa=t(" store antipattern"),Ia=i(),R=s("section"),k=s("div"),ge=s("span"),nt=t(Ze),$a=t(`
			\u2190 works because it's a `),Me=s("code"),Sa=t("mutable"),Ha=t(` store, but mutates the value directly and then
			manually calls `),ye=s("code"),Na=t(".update()"),Pa=t(", which seems like an antipattern"),Ta=i(),Ce=s("pre"),Ra=t(`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),La=i(),Q=s("h2"),qa=t("F. "),Oe=s("code"),ja=t("fastMutable"),Va=t(" store"),Wa=i(),L=s("section"),A=s("div"),De=s("span"),dt=t(xe),Ba=t(`
			\u2190 works because it's a `),ke=s("code"),Fa=t("fastMutable"),Ua=t(` store, which compared to
			`),Ae=s("code"),Ka=t("mutable"),Ga=t(` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),Qa=i(),J=s("pre"),Ja=t("fastMutableMap.update(($v) => "),za=t(Ls),Xa=t(`
	$v.set('a', $v.get('a') + 1);
});`),Ya=i(),Za=s("hr"),xa=i(),Ie=s("h2"),es=t("notes:"),ts=i(),_=s("ul"),$e=s("li"),as=t("Why care about the immutable option? See this example: "),Se=s("a"),ss=t("https://svelte.dev/examples/immutable-data"),ls=i(),et=s("li"),os=t(`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),rs=i(),tt=s("li"),cs=t(`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),ns=i(),q=s("li"),ds=t("Is "),He=s("code"),us=t("fastMutable"),is=t(`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=s("code"),hs=t("mutable"),vs=t(" implementation be preferred in all cases?"),bs=i(),j=s("li"),ps=t("Are there bettes names than "),Pe=s("code"),ms=t("mutable"),fs=t(" and "),Te=s("code"),Es=t("fastMutable"),_s=t("?"),ws=i(),V=s("li"),gs=t("Add a "),Re=s("code"),Ms=t("set"),ys=t(" store method? Probably useful for "),Le=s("code"),Cs=t("bind:"),Os=t(" usage in some cases\n			and less code than `update` to replace references."),Ds=i(),ks=s("hr"),As=i(),qe=s("footer"),je=s("a"),Is=t("public domain source code on GitHub"),this.h()},l(b){c=l(b,"MAIN",{class:!0});var n=r(c);p=l(n,"HEADER",{});var ut=r(p);m=l(ut,"H1",{class:!0});var js=r(m);f=a(js,"svelte-mutable-store"),js.forEach(o),M=h(ut),E=l(ut,"BLOCKQUOTE",{});var it=r(E);O=a(it,"how to efficiently wrap mutable values with the "),y=l(it,"CODE",{class:!0});var ht=r(y);I=a(ht,"immutable="),X=a(ht,z),ae=a(ht,"true}"),ht.forEach(o),Y=a(it," compiler flag"),it.forEach(o),ut.forEach(o),Z=h(n),C=l(n,"BUTTON",{class:!0});var Vs=r(C);at=a(Vs,"click me to make number++ go up"),Vs.forEach(o),st=h(n),v=l(n,"H2",{class:!0});var vt=r(v);$t=a(vt,"A. "),se=l(vt,"CODE",{class:!0});var Ws=r(se);St=a(Ws,"writable"),Ws.forEach(o),Ht=a(vt," store (broken! D:)"),vt.forEach(o),Nt=h(n),$=l(n,"SECTION",{});var bt=r($);S=l(bt,"DIV",{});var Ve=r(S);le=l(Ve,"SPAN",{class:!0});var Bs=r(le);lt=a(Bs,Je),Bs.forEach(o),Pt=a(Ve,`
			\u2190 fails to update as a `),oe=l(Ve,"CODE",{class:!0});var Fs=r(oe);Tt=a(Fs,"writable"),Fs.forEach(o),Rt=a(Ve," store because "),W=l(Ve,"CODE",{class:!0});var pt=r(W);Lt=a(pt,"immutable="),qt=a(pt,Ps),jt=a(pt,"true}"),pt.forEach(o),Ve.forEach(o),Vt=h(bt),re=l(bt,"PRE",{class:!0});var Us=r(re);Wt=a(Us,`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Us.forEach(o),bt.forEach(o),Bt=h(n),B=l(n,"H2",{class:!0});var mt=r(B);Ft=a(mt,"B. cloned "),ce=l(mt,"CODE",{class:!0});var Ks=r(ce);Ut=a(Ks,"writable"),Ks.forEach(o),Kt=a(mt," store"),mt.forEach(o),Gt=h(n),H=l(n,"SECTION",{});var ft=r(H);ne=l(ft,"DIV",{});var Ss=r(ne);de=l(Ss,"SPAN",{class:!0});var Gs=r(de);ot=a(Gs,ze),Gs.forEach(o),Qt=a(Ss,`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),Ss.forEach(o),Jt=h(ft),ue=l(ft,"PRE",{class:!0});var Qs=r(ue);zt=a(Qs,`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),Qs.forEach(o),ft.forEach(o),Xt=h(n),x=l(n,"BLOCKQUOTE",{});var Et=r(x);Yt=a(Et,"in the examples below, notice that you need to access "),ie=l(Et,"CODE",{class:!0});var Js=r(ie);Zt=a(Js,".value"),Js.forEach(o),xt=a(Et," for reads, unlike above"),Et.forEach(o),ea=h(n),D=l(n,"H2",{class:!0});var We=r(D);ta=a(We,"C. "),he=l(We,"CODE",{class:!0});var zs=r(he);aa=a(zs,"derived"),zs.forEach(o),sa=a(We," from "),ve=l(We,"CODE",{class:!0});var Xs=r(ve);la=a(Xs,"writable"),Xs.forEach(o),oa=a(We," store"),We.forEach(o),ra=h(n),N=l(n,"SECTION",{});var _t=r(N);be=l(_t,"DIV",{});var Hs=r(be);pe=l(Hs,"SPAN",{class:!0});var Ys=r(pe);rt=a(Ys,Xe),Ys.forEach(o),ca=a(Hs,`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),Hs.forEach(o),na=h(_t),F=l(_t,"PRE",{class:!0});var wt=r(F);da=a(wt,"const derivedWritableMap = derived(writableMap, ($v) => ("),ua=a(wt,Ts),ia=a(wt,"value: $v}));"),wt.forEach(o),_t.forEach(o),ha=h(n),U=l(n,"H2",{class:!0});var gt=r(U);va=a(gt,"D. "),me=l(gt,"CODE",{class:!0});var Zs=r(me);ba=a(Zs,"mutable"),Zs.forEach(o),pa=a(gt," store"),gt.forEach(o),ma=h(n),P=l(n,"SECTION",{});var Mt=r(P);T=l(Mt,"DIV",{});var Be=r(T);fe=l(Be,"SPAN",{class:!0});var xs=r(fe);ct=a(xs,Ye),xs.forEach(o),fa=a(Be,`
			\u2190 works because it's a `),Ee=l(Be,"CODE",{class:!0});var el=r(Ee);Ea=a(el,"mutable"),el.forEach(o),_a=a(Be,` store; doesn't clone the map; however notice that
			you need to access `),_e=l(Be,"CODE",{class:!0});var tl=r(_e);wa=a(tl,".value"),tl.forEach(o),Be.forEach(o),ga=h(Mt),K=l(Mt,"PRE",{class:!0});var yt=r(K);Ma=a(yt,"mutableMap.update(($v) => "),ya=a(yt,Rs),Ca=a(yt,`
	$v.set('a', $v.get('a') + 1);
});`),yt.forEach(o),Mt.forEach(o),Oa=h(n),G=l(n,"H2",{class:!0});var Ct=r(G);Da=a(Ct,"E. "),we=l(Ct,"CODE",{class:!0});var al=r(we);ka=a(al,"mutable"),al.forEach(o),Aa=a(Ct," store antipattern"),Ct.forEach(o),Ia=h(n),R=l(n,"SECTION",{});var Ot=r(R);k=l(Ot,"DIV",{});var ee=r(k);ge=l(ee,"SPAN",{class:!0});var sl=r(ge);nt=a(sl,Ze),sl.forEach(o),$a=a(ee,`
			\u2190 works because it's a `),Me=l(ee,"CODE",{class:!0});var ll=r(Me);Sa=a(ll,"mutable"),ll.forEach(o),Ha=a(ee,` store, but mutates the value directly and then
			manually calls `),ye=l(ee,"CODE",{class:!0});var ol=r(ye);Na=a(ol,".update()"),ol.forEach(o),Pa=a(ee,", which seems like an antipattern"),ee.forEach(o),Ta=h(Ot),Ce=l(Ot,"PRE",{class:!0});var rl=r(Ce);Ra=a(rl,`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),rl.forEach(o),Ot.forEach(o),La=h(n),Q=l(n,"H2",{class:!0});var Dt=r(Q);qa=a(Dt,"F. "),Oe=l(Dt,"CODE",{class:!0});var cl=r(Oe);ja=a(cl,"fastMutable"),cl.forEach(o),Va=a(Dt," store"),Dt.forEach(o),Wa=h(n),L=l(n,"SECTION",{});var kt=r(L);A=l(kt,"DIV",{});var te=r(A);De=l(te,"SPAN",{class:!0});var nl=r(De);dt=a(nl,xe),nl.forEach(o),Ba=a(te,`
			\u2190 works because it's a `),ke=l(te,"CODE",{class:!0});var dl=r(ke);Fa=a(dl,"fastMutable"),dl.forEach(o),Ua=a(te,` store, which compared to
			`),Ae=l(te,"CODE",{class:!0});var ul=r(Ae);Ka=a(ul,"mutable"),ul.forEach(o),Ga=a(te,` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),te.forEach(o),Qa=h(kt),J=l(kt,"PRE",{class:!0});var At=r(J);Ja=a(At,"fastMutableMap.update(($v) => "),za=a(At,Ls),Xa=a(At,`
	$v.set('a', $v.get('a') + 1);
});`),At.forEach(o),kt.forEach(o),Ya=h(n),Za=l(n,"HR",{}),xa=h(n),Ie=l(n,"H2",{class:!0});var il=r(Ie);es=a(il,"notes:"),il.forEach(o),ts=h(n),_=l(n,"UL",{});var w=r(_);$e=l(w,"LI",{});var Ns=r($e);as=a(Ns,"Why care about the immutable option? See this example: "),Se=l(Ns,"A",{href:!0});var hl=r(Se);ss=a(hl,"https://svelte.dev/examples/immutable-data"),hl.forEach(o),Ns.forEach(o),ls=h(w),et=l(w,"LI",{});var vl=r(et);os=a(vl,`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),vl.forEach(o),rs=h(w),tt=l(w,"LI",{});var bl=r(tt);cs=a(bl,`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),bl.forEach(o),ns=h(w),q=l(w,"LI",{});var Fe=r(q);ds=a(Fe,"Is "),He=l(Fe,"CODE",{class:!0});var pl=r(He);us=a(pl,"fastMutable"),pl.forEach(o),is=a(Fe,`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=l(Fe,"CODE",{class:!0});var ml=r(Ne);hs=a(ml,"mutable"),ml.forEach(o),vs=a(Fe," implementation be preferred in all cases?"),Fe.forEach(o),bs=h(w),j=l(w,"LI",{});var Ue=r(j);ps=a(Ue,"Are there bettes names than "),Pe=l(Ue,"CODE",{class:!0});var fl=r(Pe);ms=a(fl,"mutable"),fl.forEach(o),fs=a(Ue," and "),Te=l(Ue,"CODE",{class:!0});var El=r(Te);Es=a(El,"fastMutable"),El.forEach(o),_s=a(Ue,"?"),Ue.forEach(o),ws=h(w),V=l(w,"LI",{});var Ke=r(V);gs=a(Ke,"Add a "),Re=l(Ke,"CODE",{class:!0});var _l=r(Re);Ms=a(_l,"set"),_l.forEach(o),ys=a(Ke," store method? Probably useful for "),Le=l(Ke,"CODE",{class:!0});var wl=r(Le);Cs=a(wl,"bind:"),wl.forEach(o),Os=a(Ke," usage in some cases\n			and less code than `update` to replace references."),Ke.forEach(o),w.forEach(o),Ds=h(n),ks=l(n,"HR",{}),As=h(n),qe=l(n,"FOOTER",{class:!0});var gl=r(qe);je=l(gl,"A",{href:!0});var Ml=r(je);Is=a(Ml,"public domain source code on GitHub"),Ml.forEach(o),gl.forEach(o),n.forEach(o),this.h()},h(){d(m,"class","svelte-1hmclby"),d(y,"class","svelte-1hmclby"),d(C,"class","svelte-1hmclby"),d(se,"class","svelte-1hmclby"),d(v,"class","svelte-1hmclby"),d(le,"class","count svelte-1hmclby"),d(oe,"class","svelte-1hmclby"),d(W,"class","svelte-1hmclby"),d(re,"class","panel-inset svelte-1hmclby"),g($,"--hue",u[12](u[0].get("a")),!1),d(ce,"class","svelte-1hmclby"),d(B,"class","svelte-1hmclby"),d(de,"class","count svelte-1hmclby"),d(ue,"class","panel-inset svelte-1hmclby"),g(H,"--hue",u[12](u[1].get("a")),!1),d(ie,"class","svelte-1hmclby"),d(he,"class","svelte-1hmclby"),d(ve,"class","svelte-1hmclby"),d(D,"class","svelte-1hmclby"),d(pe,"class","count svelte-1hmclby"),d(F,"class","panel-inset svelte-1hmclby"),g(N,"--hue",u[12](u[3].value.get("a")),!1),d(me,"class","svelte-1hmclby"),d(U,"class","svelte-1hmclby"),d(fe,"class","count svelte-1hmclby"),d(Ee,"class","svelte-1hmclby"),d(_e,"class","svelte-1hmclby"),d(K,"class","panel-inset svelte-1hmclby"),g(P,"--hue",u[12](u[4].value.get("a")),!1),d(we,"class","svelte-1hmclby"),d(G,"class","svelte-1hmclby"),d(ge,"class","count svelte-1hmclby"),d(Me,"class","svelte-1hmclby"),d(ye,"class","svelte-1hmclby"),d(Ce,"class","panel-inset svelte-1hmclby"),g(R,"--hue",u[12](u[2].value.get("a")),!1),d(Oe,"class","svelte-1hmclby"),d(Q,"class","svelte-1hmclby"),d(De,"class","count svelte-1hmclby"),d(ke,"class","svelte-1hmclby"),d(Ae,"class","svelte-1hmclby"),d(J,"class","panel-inset svelte-1hmclby"),g(L,"--hue",u[12](u[5].value.get("a")),!1),d(Ie,"class","svelte-1hmclby"),d(Se,"href","https://svelte.dev/examples/immutable-data"),d(He,"class","svelte-1hmclby"),d(Ne,"class","svelte-1hmclby"),d(Pe,"class","svelte-1hmclby"),d(Te,"class","svelte-1hmclby"),d(Re,"class","svelte-1hmclby"),d(Le,"class","svelte-1hmclby"),d(je,"href","https://github.com/spiderspace/svelte-mutable-store"),d(qe,"class","svelte-1hmclby"),d(c,"class","markup svelte-1hmclby")},m(b,n){Al(b,c,n),e(c,p),e(p,m),e(m,f),e(p,M),e(p,E),e(E,O),e(E,y),e(y,I),e(y,X),e(y,ae),e(E,Y),e(c,Z),e(c,C),e(C,at),e(c,st),e(c,v),e(v,$t),e(v,se),e(se,St),e(v,Ht),e(c,Nt),e(c,$),e($,S),e(S,le),e(le,lt),e(S,Pt),e(S,oe),e(oe,Tt),e(S,Rt),e(S,W),e(W,Lt),e(W,qt),e(W,jt),e($,Vt),e($,re),e(re,Wt),e(c,Bt),e(c,B),e(B,Ft),e(B,ce),e(ce,Ut),e(B,Kt),e(c,Gt),e(c,H),e(H,ne),e(ne,de),e(de,ot),e(ne,Qt),e(H,Jt),e(H,ue),e(ue,zt),e(c,Xt),e(c,x),e(x,Yt),e(x,ie),e(ie,Zt),e(x,xt),e(c,ea),e(c,D),e(D,ta),e(D,he),e(he,aa),e(D,sa),e(D,ve),e(ve,la),e(D,oa),e(c,ra),e(c,N),e(N,be),e(be,pe),e(pe,rt),e(be,ca),e(N,na),e(N,F),e(F,da),e(F,ua),e(F,ia),e(c,ha),e(c,U),e(U,va),e(U,me),e(me,ba),e(U,pa),e(c,ma),e(c,P),e(P,T),e(T,fe),e(fe,ct),e(T,fa),e(T,Ee),e(Ee,Ea),e(T,_a),e(T,_e),e(_e,wa),e(P,ga),e(P,K),e(K,Ma),e(K,ya),e(K,Ca),e(c,Oa),e(c,G),e(G,Da),e(G,we),e(we,ka),e(G,Aa),e(c,Ia),e(c,R),e(R,k),e(k,ge),e(ge,nt),e(k,$a),e(k,Me),e(Me,Sa),e(k,Ha),e(k,ye),e(ye,Na),e(k,Pa),e(R,Ta),e(R,Ce),e(Ce,Ra),e(c,La),e(c,Q),e(Q,qa),e(Q,Oe),e(Oe,ja),e(Q,Va),e(c,Wa),e(c,L),e(L,A),e(A,De),e(De,dt),e(A,Ba),e(A,ke),e(ke,Fa),e(A,Ua),e(A,Ae),e(Ae,Ka),e(A,Ga),e(L,Qa),e(L,J),e(J,Ja),e(J,za),e(J,Xa),e(c,Ya),e(c,Za),e(c,xa),e(c,Ie),e(Ie,es),e(c,ts),e(c,_),e(_,$e),e($e,as),e($e,Se),e(Se,ss),e(_,ls),e(_,et),e(et,os),e(_,rs),e(_,tt),e(tt,cs),e(_,ns),e(_,q),e(q,ds),e(q,He),e(He,us),e(q,is),e(q,Ne),e(Ne,hs),e(q,vs),e(_,bs),e(_,j),e(j,ps),e(j,Pe),e(Pe,ms),e(j,fs),e(j,Te),e(Te,Es),e(j,_s),e(_,ws),e(_,V),e(V,gs),e(V,Re),e(Re,Ms),e(V,ys),e(V,Le),e(Le,Cs),e(V,Os),e(c,Ds),e(c,ks),e(c,As),e(c,qe),e(qe,je),e(je,Is),$s||(qs=Il(C,"click",u[13]),$s=!0)},p(b,[n]){n&1&&Je!==(Je=b[0].get("a")+"")&&Ge(lt,Je),n&1&&g($,"--hue",b[12](b[0].get("a")),!1),n&2&&ze!==(ze=b[1].get("a")+"")&&Ge(ot,ze),n&2&&g(H,"--hue",b[12](b[1].get("a")),!1),n&8&&Xe!==(Xe=b[3].value.get("a")+"")&&Ge(rt,Xe),n&8&&g(N,"--hue",b[12](b[3].value.get("a")),!1),n&16&&Ye!==(Ye=b[4].value.get("a")+"")&&Ge(ct,Ye),n&16&&g(P,"--hue",b[12](b[4].value.get("a")),!1),n&4&&Ze!==(Ze=b[2].value.get("a")+"")&&Ge(nt,Ze),n&4&&g(R,"--hue",b[12](b[2].value.get("a")),!1),n&32&&xe!==(xe=b[5].value.get("a")+"")&&Ge(dt,xe),n&32&&g(L,"--hue",b[12](b[5].value.get("a")),!1)},i:yl,o:yl,d(b){b&&o(c),$s=!1,qs()}}}function Pl(u,c,p){let m,f,M,E,O,y;const I=[["a",1]],z=It(new Map(I));Qe(u,z,v=>p(0,m=v));const X=It(new Map(I));Qe(u,X,v=>p(1,f=v));const ae=$l(z,v=>({value:v}));Qe(u,ae,v=>p(3,E=v));const Y=Cl(new Map(I));Qe(u,Y,v=>p(4,O=v));const Z=Cl(new Map(I));Qe(u,Z,v=>p(2,M=v));const C=Hl(new Map(I));return Qe(u,C,v=>p(5,y=v)),[m,f,M,E,O,y,z,X,ae,Y,Z,C,v=>v*37+"",()=>{m.set("a",m.get("a")+1),z.set(m),f.set("a",f.get("a")+1),Sl(X,f=new Map(f),f),Y.update(v=>{v.set("a",v.get("a")+1)}),M.value.set("a",M.value.get("a")+1),Z.update(),C.update(v=>{v.set("a",v.get("a")+1)})}]}class Rl extends Ol{constructor(c){super();Dl(this,c,Pl,Nl,kl,{})}}export{Rl as default};
