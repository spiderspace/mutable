import{C as At,S as Dl,i as Al,n as Il,e as s,t,j as i,c as l,a as r,g as a,d as o,m as v,b as u,K as w,f as $l,F as e,L as Sl,s as Ke,J as Cl,M as Qe,N as Hl,O as yl}from"../chunks/vendor-7ffe92ef.js";const Ol=d=>{const{subscribe:n,set:b}=At({value:d});return{subscribe:n,update:f=>{if(f){const m=f(d);m!==void 0&&m!==d&&(d=m)}b({value:d})},set:f=>{d=f,b({value:d})}}},Nl=d=>{let n=!1;const b={value:d},f={value:d},{subscribe:m,set:k}=At(b);return{subscribe:m,update:M=>{if(M){const g=M(d);g!==void 0&&g!==d&&(d=b.value=f.value=g)}k((n=!n)?f:b)},set:M=>{d=b.value=f.value=M,k((n=!n)?f:b)}}};function Pl(d){let n,b,f,m,k,M,g,ae,_,W,X,I,Y,Z,C,st,lt,h,It,se,$t,St,Ht,$,S,le,Je=d[0].get("a")+"",ot,yt,oe,Nt,Pt,B,Tt,ys="{",Rt,Lt,qt,re,Vt,Wt,F,Bt,ne,Ft,Gt,Ut,H,ce,ue,ze=d[1].get("a")+"",rt,Kt,Qt,de,Jt,zt,x,Xt,ie,Yt,Zt,xt,O,ea,ve,ta,aa,he,sa,la,oa,y,pe,be,Xe=d[3].value.get("a")+"",nt,ra,na,G,ca,Ns="{",ua,da,ia,U,va,fe,ha,pa,ba,N,P,me,Ye=d[4].value.get("a")+"",ct,fa,ge,ma,ga,Ee,Ea,_a,K,ja,Ps="{",wa,ka,Ma,Q,Ca,_e,Oa,Da,Aa,T,D,je,Ze=d[2].value.get("a")+"",ut,Ia,we,$a,Sa,ke,Ha,ya,Na,Me,Pa,Ta,J,Ra,Ce,La,qa,Va,R,A,Oe,xe=d[5].value.get("a")+"",dt,Wa,De,Ba,Fa,Ae,Ga,Ua,Ka,z,Qa,Ts="{",Ja,za,Xa,Ya,Za,Ie,xa,es,E,$e,ts,Se,as,ss,et,ls,os,tt,rs,ns,L,cs,He,us,ds,ye,is,vs,hs,q,ps,Ne,bs,fs,Pe,ms,gs,Es,V,_s,Te,js,ws,Re,ks,Ms,Cs,Os,Ds,Le,qe,As,Is,Rs;return{c(){n=s("main"),b=s("header"),f=s("h1"),m=s("a"),k=t("svelte-mutable-store"),M=i(),g=s("blockquote"),ae=t("using mutable values in Svelte stores with the "),_=s("code"),W=t("immutable"),X=t(` compiler flag.
			`),I=s("a"),Y=t("learn more on GitHub"),Z=i(),C=s("button"),st=t("click me to make number++ go up"),lt=i(),h=s("h2"),It=t("A. "),se=s("code"),$t=t("writable"),St=t(" store (broken! D:)"),Ht=i(),$=s("section"),S=s("div"),le=s("span"),ot=t(Je),yt=t(`
			\u2190 fails to update as a `),oe=s("code"),Nt=t("writable"),Pt=t(" store because "),B=s("code"),Tt=t("immutable="),Rt=t(ys),Lt=t("true}"),qt=i(),re=s("pre"),Vt=t(`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Wt=i(),F=s("h2"),Bt=t("B. cloned "),ne=s("code"),Ft=t("writable"),Gt=t(" store"),Ut=i(),H=s("section"),ce=s("div"),ue=s("span"),rt=t(ze),Kt=t(`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),Qt=i(),de=s("pre"),Jt=t(`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),zt=i(),x=s("blockquote"),Xt=t("in the examples below, notice that you need to access "),ie=s("code"),Yt=t(".value"),Zt=t(" for reads, unlike above"),xt=i(),O=s("h2"),ea=t("C. "),ve=s("code"),ta=t("derived"),aa=t(" from "),he=s("code"),sa=t("writable"),la=t(" store"),oa=i(),y=s("section"),pe=s("div"),be=s("span"),nt=t(Xe),ra=t(`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),na=i(),G=s("pre"),ca=t("const derivedWritableMap = derived(writableMap, ($v) => ("),ua=t(Ns),da=t("value: $v}));"),ia=i(),U=s("h2"),va=t("D. "),fe=s("code"),ha=t("mutable"),pa=t(" store"),ba=i(),N=s("section"),P=s("div"),me=s("span"),ct=t(Ye),fa=t(`
			\u2190 works because it's a `),ge=s("code"),ma=t("mutable"),ga=t(` store; doesn't clone the map; however notice that
			you need to access `),Ee=s("code"),Ea=t(".value"),_a=i(),K=s("pre"),ja=t("mutableMap.update(($v) => "),wa=t(Ps),ka=t(`
	$v.set('a', $v.get('a') + 1);
});`),Ma=i(),Q=s("h2"),Ca=t("E. "),_e=s("code"),Oa=t("mutable"),Da=t(" store antipattern"),Aa=i(),T=s("section"),D=s("div"),je=s("span"),ut=t(Ze),Ia=t(`
			\u2190 works because it's a `),we=s("code"),$a=t("mutable"),Sa=t(` store, but mutates the value directly and then
			manually calls `),ke=s("code"),Ha=t(".update()"),ya=t(", which seems like an antipattern"),Na=i(),Me=s("pre"),Pa=t(`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),Ta=i(),J=s("h2"),Ra=t("F. "),Ce=s("code"),La=t("fastMutable"),qa=t(" store"),Va=i(),R=s("section"),A=s("div"),Oe=s("span"),dt=t(xe),Wa=t(`
			\u2190 works because it's a `),De=s("code"),Ba=t("fastMutable"),Fa=t(` store, which compared to
			`),Ae=s("code"),Ga=t("mutable"),Ua=t(` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),Ka=i(),z=s("pre"),Qa=t("fastMutableMap.update(($v) => "),Ja=t(Ts),za=t(`
	$v.set('a', $v.get('a') + 1);
});`),Xa=i(),Ya=s("hr"),Za=i(),Ie=s("h2"),xa=t("notes:"),es=i(),E=s("ul"),$e=s("li"),ts=t("Why care about the immutable option? See this example: "),Se=s("a"),as=t("https://svelte.dev/examples/immutable-data"),ss=i(),et=s("li"),ls=t(`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),os=i(),tt=s("li"),rs=t(`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),ns=i(),L=s("li"),cs=t("Is "),He=s("code"),us=t("fastMutable"),ds=t(`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),ye=s("code"),is=t("mutable"),vs=t(" implementation be preferred in all cases?"),hs=i(),q=s("li"),ps=t("Are there bettes names than "),Ne=s("code"),bs=t("mutable"),fs=t(" and "),Pe=s("code"),ms=t("fastMutable"),gs=t("?"),Es=i(),V=s("li"),_s=t("Add a "),Te=s("code"),js=t("set"),ws=t(" store method? Probably useful for "),Re=s("code"),ks=t("bind:"),Ms=t(" usage in some cases\n			and less code than `update` to replace references."),Cs=i(),Os=s("hr"),Ds=i(),Le=s("footer"),qe=s("a"),As=t("public domain source code on GitHub"),this.h()},l(p){n=l(p,"MAIN",{class:!0});var c=r(n);b=l(c,"HEADER",{});var it=r(b);f=l(it,"H1",{class:!0});var Ls=r(f);m=l(Ls,"A",{href:!0});var qs=r(m);k=a(qs,"svelte-mutable-store"),qs.forEach(o),Ls.forEach(o),M=v(it),g=l(it,"BLOCKQUOTE",{});var at=r(g);ae=a(at,"using mutable values in Svelte stores with the "),_=l(at,"CODE",{class:!0});var Vs=r(_);W=a(Vs,"immutable"),Vs.forEach(o),X=a(at,` compiler flag.
			`),I=l(at,"A",{href:!0});var Ws=r(I);Y=a(Ws,"learn more on GitHub"),Ws.forEach(o),at.forEach(o),it.forEach(o),Z=v(c),C=l(c,"BUTTON",{class:!0});var Bs=r(C);st=a(Bs,"click me to make number++ go up"),Bs.forEach(o),lt=v(c),h=l(c,"H2",{class:!0});var vt=r(h);It=a(vt,"A. "),se=l(vt,"CODE",{class:!0});var Fs=r(se);$t=a(Fs,"writable"),Fs.forEach(o),St=a(vt," store (broken! D:)"),vt.forEach(o),Ht=v(c),$=l(c,"SECTION",{});var ht=r($);S=l(ht,"DIV",{});var Ve=r(S);le=l(Ve,"SPAN",{class:!0});var Gs=r(le);ot=a(Gs,Je),Gs.forEach(o),yt=a(Ve,`
			\u2190 fails to update as a `),oe=l(Ve,"CODE",{class:!0});var Us=r(oe);Nt=a(Us,"writable"),Us.forEach(o),Pt=a(Ve," store because "),B=l(Ve,"CODE",{class:!0});var pt=r(B);Tt=a(pt,"immutable="),Rt=a(pt,ys),Lt=a(pt,"true}"),pt.forEach(o),Ve.forEach(o),qt=v(ht),re=l(ht,"PRE",{class:!0});var Ks=r(re);Vt=a(Ks,`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Ks.forEach(o),ht.forEach(o),Wt=v(c),F=l(c,"H2",{class:!0});var bt=r(F);Bt=a(bt,"B. cloned "),ne=l(bt,"CODE",{class:!0});var Qs=r(ne);Ft=a(Qs,"writable"),Qs.forEach(o),Gt=a(bt," store"),bt.forEach(o),Ut=v(c),H=l(c,"SECTION",{});var ft=r(H);ce=l(ft,"DIV",{});var $s=r(ce);ue=l($s,"SPAN",{class:!0});var Js=r(ue);rt=a(Js,ze),Js.forEach(o),Kt=a($s,`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),$s.forEach(o),Qt=v(ft),de=l(ft,"PRE",{class:!0});var zs=r(de);Jt=a(zs,`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),zs.forEach(o),ft.forEach(o),zt=v(c),x=l(c,"BLOCKQUOTE",{});var mt=r(x);Xt=a(mt,"in the examples below, notice that you need to access "),ie=l(mt,"CODE",{class:!0});var Xs=r(ie);Yt=a(Xs,".value"),Xs.forEach(o),Zt=a(mt," for reads, unlike above"),mt.forEach(o),xt=v(c),O=l(c,"H2",{class:!0});var We=r(O);ea=a(We,"C. "),ve=l(We,"CODE",{class:!0});var Ys=r(ve);ta=a(Ys,"derived"),Ys.forEach(o),aa=a(We," from "),he=l(We,"CODE",{class:!0});var Zs=r(he);sa=a(Zs,"writable"),Zs.forEach(o),la=a(We," store"),We.forEach(o),oa=v(c),y=l(c,"SECTION",{});var gt=r(y);pe=l(gt,"DIV",{});var Ss=r(pe);be=l(Ss,"SPAN",{class:!0});var xs=r(be);nt=a(xs,Xe),xs.forEach(o),ra=a(Ss,`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),Ss.forEach(o),na=v(gt),G=l(gt,"PRE",{class:!0});var Et=r(G);ca=a(Et,"const derivedWritableMap = derived(writableMap, ($v) => ("),ua=a(Et,Ns),da=a(Et,"value: $v}));"),Et.forEach(o),gt.forEach(o),ia=v(c),U=l(c,"H2",{class:!0});var _t=r(U);va=a(_t,"D. "),fe=l(_t,"CODE",{class:!0});var el=r(fe);ha=a(el,"mutable"),el.forEach(o),pa=a(_t," store"),_t.forEach(o),ba=v(c),N=l(c,"SECTION",{});var jt=r(N);P=l(jt,"DIV",{});var Be=r(P);me=l(Be,"SPAN",{class:!0});var tl=r(me);ct=a(tl,Ye),tl.forEach(o),fa=a(Be,`
			\u2190 works because it's a `),ge=l(Be,"CODE",{class:!0});var al=r(ge);ma=a(al,"mutable"),al.forEach(o),ga=a(Be,` store; doesn't clone the map; however notice that
			you need to access `),Ee=l(Be,"CODE",{class:!0});var sl=r(Ee);Ea=a(sl,".value"),sl.forEach(o),Be.forEach(o),_a=v(jt),K=l(jt,"PRE",{class:!0});var wt=r(K);ja=a(wt,"mutableMap.update(($v) => "),wa=a(wt,Ps),ka=a(wt,`
	$v.set('a', $v.get('a') + 1);
});`),wt.forEach(o),jt.forEach(o),Ma=v(c),Q=l(c,"H2",{class:!0});var kt=r(Q);Ca=a(kt,"E. "),_e=l(kt,"CODE",{class:!0});var ll=r(_e);Oa=a(ll,"mutable"),ll.forEach(o),Da=a(kt," store antipattern"),kt.forEach(o),Aa=v(c),T=l(c,"SECTION",{});var Mt=r(T);D=l(Mt,"DIV",{});var ee=r(D);je=l(ee,"SPAN",{class:!0});var ol=r(je);ut=a(ol,Ze),ol.forEach(o),Ia=a(ee,`
			\u2190 works because it's a `),we=l(ee,"CODE",{class:!0});var rl=r(we);$a=a(rl,"mutable"),rl.forEach(o),Sa=a(ee,` store, but mutates the value directly and then
			manually calls `),ke=l(ee,"CODE",{class:!0});var nl=r(ke);Ha=a(nl,".update()"),nl.forEach(o),ya=a(ee,", which seems like an antipattern"),ee.forEach(o),Na=v(Mt),Me=l(Mt,"PRE",{class:!0});var cl=r(Me);Pa=a(cl,`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),cl.forEach(o),Mt.forEach(o),Ta=v(c),J=l(c,"H2",{class:!0});var Ct=r(J);Ra=a(Ct,"F. "),Ce=l(Ct,"CODE",{class:!0});var ul=r(Ce);La=a(ul,"fastMutable"),ul.forEach(o),qa=a(Ct," store"),Ct.forEach(o),Va=v(c),R=l(c,"SECTION",{});var Ot=r(R);A=l(Ot,"DIV",{});var te=r(A);Oe=l(te,"SPAN",{class:!0});var dl=r(Oe);dt=a(dl,xe),dl.forEach(o),Wa=a(te,`
			\u2190 works because it's a `),De=l(te,"CODE",{class:!0});var il=r(De);Ba=a(il,"fastMutable"),il.forEach(o),Fa=a(te,` store, which compared to
			`),Ae=l(te,"CODE",{class:!0});var vl=r(Ae);Ga=a(vl,"mutable"),vl.forEach(o),Ua=a(te,` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),te.forEach(o),Ka=v(Ot),z=l(Ot,"PRE",{class:!0});var Dt=r(z);Qa=a(Dt,"fastMutableMap.update(($v) => "),Ja=a(Dt,Ts),za=a(Dt,`
	$v.set('a', $v.get('a') + 1);
});`),Dt.forEach(o),Ot.forEach(o),Xa=v(c),Ya=l(c,"HR",{}),Za=v(c),Ie=l(c,"H2",{class:!0});var hl=r(Ie);xa=a(hl,"notes:"),hl.forEach(o),es=v(c),E=l(c,"UL",{});var j=r(E);$e=l(j,"LI",{});var Hs=r($e);ts=a(Hs,"Why care about the immutable option? See this example: "),Se=l(Hs,"A",{href:!0});var pl=r(Se);as=a(pl,"https://svelte.dev/examples/immutable-data"),pl.forEach(o),Hs.forEach(o),ss=v(j),et=l(j,"LI",{});var bl=r(et);ls=a(bl,`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),bl.forEach(o),os=v(j),tt=l(j,"LI",{});var fl=r(tt);rs=a(fl,`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),fl.forEach(o),ns=v(j),L=l(j,"LI",{});var Fe=r(L);cs=a(Fe,"Is "),He=l(Fe,"CODE",{class:!0});var ml=r(He);us=a(ml,"fastMutable"),ml.forEach(o),ds=a(Fe,`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),ye=l(Fe,"CODE",{class:!0});var gl=r(ye);is=a(gl,"mutable"),gl.forEach(o),vs=a(Fe," implementation be preferred in all cases?"),Fe.forEach(o),hs=v(j),q=l(j,"LI",{});var Ge=r(q);ps=a(Ge,"Are there bettes names than "),Ne=l(Ge,"CODE",{class:!0});var El=r(Ne);bs=a(El,"mutable"),El.forEach(o),fs=a(Ge," and "),Pe=l(Ge,"CODE",{class:!0});var _l=r(Pe);ms=a(_l,"fastMutable"),_l.forEach(o),gs=a(Ge,"?"),Ge.forEach(o),Es=v(j),V=l(j,"LI",{});var Ue=r(V);_s=a(Ue,"Add a "),Te=l(Ue,"CODE",{class:!0});var jl=r(Te);js=a(jl,"set"),jl.forEach(o),ws=a(Ue," store method? Probably useful for "),Re=l(Ue,"CODE",{class:!0});var wl=r(Re);ks=a(wl,"bind:"),wl.forEach(o),Ms=a(Ue," usage in some cases\n			and less code than `update` to replace references."),Ue.forEach(o),j.forEach(o),Cs=v(c),Os=l(c,"HR",{}),Ds=v(c),Le=l(c,"FOOTER",{class:!0});var kl=r(Le);qe=l(kl,"A",{href:!0});var Ml=r(qe);As=a(Ml,"public domain source code on GitHub"),Ml.forEach(o),kl.forEach(o),c.forEach(o),this.h()},h(){u(m,"href","https://github.com/spiderspace/svelte-mutable-store"),u(f,"class","svelte-1kjjogv"),u(_,"class","svelte-1kjjogv"),u(I,"href","https://github.com/spiderspace/svelte-mutable-store"),u(C,"class","svelte-1kjjogv"),u(se,"class","svelte-1kjjogv"),u(h,"class","svelte-1kjjogv"),u(le,"class","count svelte-1kjjogv"),u(oe,"class","svelte-1kjjogv"),u(B,"class","svelte-1kjjogv"),u(re,"class","panel-inset svelte-1kjjogv"),w($,"--hue",d[12](d[0].get("a")),!1),u(ne,"class","svelte-1kjjogv"),u(F,"class","svelte-1kjjogv"),u(ue,"class","count svelte-1kjjogv"),u(de,"class","panel-inset svelte-1kjjogv"),w(H,"--hue",d[12](d[1].get("a")),!1),u(ie,"class","svelte-1kjjogv"),u(ve,"class","svelte-1kjjogv"),u(he,"class","svelte-1kjjogv"),u(O,"class","svelte-1kjjogv"),u(be,"class","count svelte-1kjjogv"),u(G,"class","panel-inset svelte-1kjjogv"),w(y,"--hue",d[12](d[3].value.get("a")),!1),u(fe,"class","svelte-1kjjogv"),u(U,"class","svelte-1kjjogv"),u(me,"class","count svelte-1kjjogv"),u(ge,"class","svelte-1kjjogv"),u(Ee,"class","svelte-1kjjogv"),u(K,"class","panel-inset svelte-1kjjogv"),w(N,"--hue",d[12](d[4].value.get("a")),!1),u(_e,"class","svelte-1kjjogv"),u(Q,"class","svelte-1kjjogv"),u(je,"class","count svelte-1kjjogv"),u(we,"class","svelte-1kjjogv"),u(ke,"class","svelte-1kjjogv"),u(Me,"class","panel-inset svelte-1kjjogv"),w(T,"--hue",d[12](d[2].value.get("a")),!1),u(Ce,"class","svelte-1kjjogv"),u(J,"class","svelte-1kjjogv"),u(Oe,"class","count svelte-1kjjogv"),u(De,"class","svelte-1kjjogv"),u(Ae,"class","svelte-1kjjogv"),u(z,"class","panel-inset svelte-1kjjogv"),w(R,"--hue",d[12](d[5].value.get("a")),!1),u(Ie,"class","svelte-1kjjogv"),u(Se,"href","https://svelte.dev/examples/immutable-data"),u(He,"class","svelte-1kjjogv"),u(ye,"class","svelte-1kjjogv"),u(Ne,"class","svelte-1kjjogv"),u(Pe,"class","svelte-1kjjogv"),u(Te,"class","svelte-1kjjogv"),u(Re,"class","svelte-1kjjogv"),u(qe,"href","https://github.com/spiderspace/svelte-mutable-store"),u(Le,"class","svelte-1kjjogv"),u(n,"class","markup column svelte-1kjjogv")},m(p,c){$l(p,n,c),e(n,b),e(b,f),e(f,m),e(m,k),e(b,M),e(b,g),e(g,ae),e(g,_),e(_,W),e(g,X),e(g,I),e(I,Y),e(n,Z),e(n,C),e(C,st),e(n,lt),e(n,h),e(h,It),e(h,se),e(se,$t),e(h,St),e(n,Ht),e(n,$),e($,S),e(S,le),e(le,ot),e(S,yt),e(S,oe),e(oe,Nt),e(S,Pt),e(S,B),e(B,Tt),e(B,Rt),e(B,Lt),e($,qt),e($,re),e(re,Vt),e(n,Wt),e(n,F),e(F,Bt),e(F,ne),e(ne,Ft),e(F,Gt),e(n,Ut),e(n,H),e(H,ce),e(ce,ue),e(ue,rt),e(ce,Kt),e(H,Qt),e(H,de),e(de,Jt),e(n,zt),e(n,x),e(x,Xt),e(x,ie),e(ie,Yt),e(x,Zt),e(n,xt),e(n,O),e(O,ea),e(O,ve),e(ve,ta),e(O,aa),e(O,he),e(he,sa),e(O,la),e(n,oa),e(n,y),e(y,pe),e(pe,be),e(be,nt),e(pe,ra),e(y,na),e(y,G),e(G,ca),e(G,ua),e(G,da),e(n,ia),e(n,U),e(U,va),e(U,fe),e(fe,ha),e(U,pa),e(n,ba),e(n,N),e(N,P),e(P,me),e(me,ct),e(P,fa),e(P,ge),e(ge,ma),e(P,ga),e(P,Ee),e(Ee,Ea),e(N,_a),e(N,K),e(K,ja),e(K,wa),e(K,ka),e(n,Ma),e(n,Q),e(Q,Ca),e(Q,_e),e(_e,Oa),e(Q,Da),e(n,Aa),e(n,T),e(T,D),e(D,je),e(je,ut),e(D,Ia),e(D,we),e(we,$a),e(D,Sa),e(D,ke),e(ke,Ha),e(D,ya),e(T,Na),e(T,Me),e(Me,Pa),e(n,Ta),e(n,J),e(J,Ra),e(J,Ce),e(Ce,La),e(J,qa),e(n,Va),e(n,R),e(R,A),e(A,Oe),e(Oe,dt),e(A,Wa),e(A,De),e(De,Ba),e(A,Fa),e(A,Ae),e(Ae,Ga),e(A,Ua),e(R,Ka),e(R,z),e(z,Qa),e(z,Ja),e(z,za),e(n,Xa),e(n,Ya),e(n,Za),e(n,Ie),e(Ie,xa),e(n,es),e(n,E),e(E,$e),e($e,ts),e($e,Se),e(Se,as),e(E,ss),e(E,et),e(et,ls),e(E,os),e(E,tt),e(tt,rs),e(E,ns),e(E,L),e(L,cs),e(L,He),e(He,us),e(L,ds),e(L,ye),e(ye,is),e(L,vs),e(E,hs),e(E,q),e(q,ps),e(q,Ne),e(Ne,bs),e(q,fs),e(q,Pe),e(Pe,ms),e(q,gs),e(E,Es),e(E,V),e(V,_s),e(V,Te),e(Te,js),e(V,ws),e(V,Re),e(Re,ks),e(V,Ms),e(n,Cs),e(n,Os),e(n,Ds),e(n,Le),e(Le,qe),e(qe,As),Is||(Rs=Sl(C,"click",d[13]),Is=!0)},p(p,[c]){c&1&&Je!==(Je=p[0].get("a")+"")&&Ke(ot,Je),c&1&&w($,"--hue",p[12](p[0].get("a")),!1),c&2&&ze!==(ze=p[1].get("a")+"")&&Ke(rt,ze),c&2&&w(H,"--hue",p[12](p[1].get("a")),!1),c&8&&Xe!==(Xe=p[3].value.get("a")+"")&&Ke(nt,Xe),c&8&&w(y,"--hue",p[12](p[3].value.get("a")),!1),c&16&&Ye!==(Ye=p[4].value.get("a")+"")&&Ke(ct,Ye),c&16&&w(N,"--hue",p[12](p[4].value.get("a")),!1),c&4&&Ze!==(Ze=p[2].value.get("a")+"")&&Ke(ut,Ze),c&4&&w(T,"--hue",p[12](p[2].value.get("a")),!1),c&32&&xe!==(xe=p[5].value.get("a")+"")&&Ke(dt,xe),c&32&&w(R,"--hue",p[12](p[5].value.get("a")),!1)},i:Cl,o:Cl,d(p){p&&o(n),Is=!1,Rs()}}}function Tl(d,n,b){let f,m,k,M,g,ae;const _=[["a",1]],W=At(new Map(_));Qe(d,W,h=>b(0,f=h));const X=At(new Map(_));Qe(d,X,h=>b(1,m=h));const I=Hl(W,h=>({value:h}));Qe(d,I,h=>b(3,M=h));const Y=Ol(new Map(_));Qe(d,Y,h=>b(4,g=h));const Z=Ol(new Map(_));Qe(d,Z,h=>b(2,k=h));const C=Nl(new Map(_));return Qe(d,C,h=>b(5,ae=h)),[f,m,k,M,g,ae,W,X,I,Y,Z,C,h=>h*37+"",()=>{f.set("a",f.get("a")+1),W.set(f),m.set("a",m.get("a")+1),yl(X,m=new Map(m),m),Y.update(h=>{h.set("a",h.get("a")+1)}),k.value.set("a",k.value.get("a")+1),Z.update(),C.update(h=>{h.set("a",h.get("a")+1)})}]}class Ll extends Dl{constructor(n){super();Al(this,n,Tl,Pl,Il,{})}}export{Ll as default};
