import{C as kt,S as Ml,i as yl,n as Cl,e as s,t,j as i,c as l,a as r,g as a,d as o,m as h,b as d,K as M,f as Ol,F as e,L as Dl,s as Ge,J as gl,M as Qe,N as kl,O as Al}from"../chunks/vendor-7ffe92ef.js";const wl=u=>{const{subscribe:n,set:p}=kt({value:u});return{subscribe:n,update:m=>{if(m){const f=m(u);f!==void 0&&f!==u&&(u=f)}p({value:u})},set:m=>{u=m,p({value:u})}}},Il=u=>{let n=!1;const p={value:u},m={value:u},{subscribe:f,set:y}=kt(p);return{subscribe:f,update:E=>{if(E){const C=E(u);C!==void 0&&C!==u&&(u=p.value=m.value=C)}y((n=!n)?m:p)},set:E=>{u=p.value=m.value=E,y((n=!n)?m:p)}}};function $l(u){let n,p,m,f,y,E,C,I,$,B,Y,O,Z,x,g,at,ee,v,At,It,S,H,le,Je=u[0].get("a")+"",st,$t,oe,St,Ht,F,Nt,$s="{",Pt,Tt,Rt,re,Lt,qt,U,jt,ne,Vt,Wt,Bt,N,ce,de,ze=u[1].get("a")+"",lt,Ft,Ut,ue,Kt,Gt,te,Qt,ie,Jt,zt,Xt,D,Yt,he,Zt,xt,ve,ea,ta,aa,P,be,pe,Xe=u[3].value.get("a")+"",ot,sa,la,K,oa,Ss="{",ra,na,ca,G,da,me,ua,ia,ha,T,R,fe,Ye=u[4].value.get("a")+"",rt,va,Ee,ba,pa,_e,ma,fa,Q,Ea,Hs="{",_a,ga,wa,J,Ma,ge,ya,Ca,Oa,L,k,we,Ze=u[2].value.get("a")+"",nt,Da,Me,ka,Aa,ye,Ia,$a,Sa,Ce,Ha,Na,z,Pa,Oe,Ta,Ra,La,q,A,De,xe=u[5].value.get("a")+"",ct,qa,ke,ja,Va,Ae,Wa,Ba,Fa,X,Ua,Ns="{",Ka,Ga,Qa,Ja,za,Ie,Xa,Ya,_,$e,Za,Se,xa,es,et,ts,as,tt,ss,ls,j,os,He,rs,ns,Ne,cs,ds,us,V,is,Pe,hs,vs,Te,bs,ps,ms,W,fs,Re,Es,_s,Le,gs,ws,Ms,ys,Cs,qe,je,Os,Ds,Ps;return{c(){n=s("main"),p=s("header"),m=s("h1"),f=t("svelte-mutable-store"),y=i(),E=s("blockquote"),C=t("using mutable values in Svelte stores with the "),I=s("code"),$=t("immutable"),B=t(" compiler flag"),Y=i(),O=s("button"),Z=t("click me to make number++ go up"),x=i(),g=s("h2"),at=t("A. "),ee=s("code"),v=t("writable"),At=t(" store (broken! D:)"),It=i(),S=s("section"),H=s("div"),le=s("span"),st=t(Je),$t=t(`
			\u2190 fails to update as a `),oe=s("code"),St=t("writable"),Ht=t(" store because "),F=s("code"),Nt=t("immutable="),Pt=t($s),Tt=t("true}"),Rt=i(),re=s("pre"),Lt=t(`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),qt=i(),U=s("h2"),jt=t("B. cloned "),ne=s("code"),Vt=t("writable"),Wt=t(" store"),Bt=i(),N=s("section"),ce=s("div"),de=s("span"),lt=t(ze),Ft=t(`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),Ut=i(),ue=s("pre"),Kt=t(`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),Gt=i(),te=s("blockquote"),Qt=t("in the examples below, notice that you need to access "),ie=s("code"),Jt=t(".value"),zt=t(" for reads, unlike above"),Xt=i(),D=s("h2"),Yt=t("C. "),he=s("code"),Zt=t("derived"),xt=t(" from "),ve=s("code"),ea=t("writable"),ta=t(" store"),aa=i(),P=s("section"),be=s("div"),pe=s("span"),ot=t(Xe),sa=t(`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),la=i(),K=s("pre"),oa=t("const derivedWritableMap = derived(writableMap, ($v) => ("),ra=t(Ss),na=t("value: $v}));"),ca=i(),G=s("h2"),da=t("D. "),me=s("code"),ua=t("mutable"),ia=t(" store"),ha=i(),T=s("section"),R=s("div"),fe=s("span"),rt=t(Ye),va=t(`
			\u2190 works because it's a `),Ee=s("code"),ba=t("mutable"),pa=t(` store; doesn't clone the map; however notice that
			you need to access `),_e=s("code"),ma=t(".value"),fa=i(),Q=s("pre"),Ea=t("mutableMap.update(($v) => "),_a=t(Hs),ga=t(`
	$v.set('a', $v.get('a') + 1);
});`),wa=i(),J=s("h2"),Ma=t("E. "),ge=s("code"),ya=t("mutable"),Ca=t(" store antipattern"),Oa=i(),L=s("section"),k=s("div"),we=s("span"),nt=t(Ze),Da=t(`
			\u2190 works because it's a `),Me=s("code"),ka=t("mutable"),Aa=t(` store, but mutates the value directly and then
			manually calls `),ye=s("code"),Ia=t(".update()"),$a=t(", which seems like an antipattern"),Sa=i(),Ce=s("pre"),Ha=t(`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),Na=i(),z=s("h2"),Pa=t("F. "),Oe=s("code"),Ta=t("fastMutable"),Ra=t(" store"),La=i(),q=s("section"),A=s("div"),De=s("span"),ct=t(xe),qa=t(`
			\u2190 works because it's a `),ke=s("code"),ja=t("fastMutable"),Va=t(` store, which compared to
			`),Ae=s("code"),Wa=t("mutable"),Ba=t(` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),Fa=i(),X=s("pre"),Ua=t("fastMutableMap.update(($v) => "),Ka=t(Ns),Ga=t(`
	$v.set('a', $v.get('a') + 1);
});`),Qa=i(),Ja=s("hr"),za=i(),Ie=s("h2"),Xa=t("notes:"),Ya=i(),_=s("ul"),$e=s("li"),Za=t("Why care about the immutable option? See this example: "),Se=s("a"),xa=t("https://svelte.dev/examples/immutable-data"),es=i(),et=s("li"),ts=t(`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),as=i(),tt=s("li"),ss=t(`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),ls=i(),j=s("li"),os=t("Is "),He=s("code"),rs=t("fastMutable"),ns=t(`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=s("code"),cs=t("mutable"),ds=t(" implementation be preferred in all cases?"),us=i(),V=s("li"),is=t("Are there bettes names than "),Pe=s("code"),hs=t("mutable"),vs=t(" and "),Te=s("code"),bs=t("fastMutable"),ps=t("?"),ms=i(),W=s("li"),fs=t("Add a "),Re=s("code"),Es=t("set"),_s=t(" store method? Probably useful for "),Le=s("code"),gs=t("bind:"),ws=t(" usage in some cases\n			and less code than `update` to replace references."),Ms=i(),ys=s("hr"),Cs=i(),qe=s("footer"),je=s("a"),Os=t("public domain source code on GitHub"),this.h()},l(b){n=l(b,"MAIN",{class:!0});var c=r(n);p=l(c,"HEADER",{});var dt=r(p);m=l(dt,"H1",{class:!0});var Ts=r(m);f=a(Ts,"svelte-mutable-store"),Ts.forEach(o),y=h(dt),E=l(dt,"BLOCKQUOTE",{});var ut=r(E);C=a(ut,"using mutable values in Svelte stores with the "),I=l(ut,"CODE",{class:!0});var Rs=r(I);$=a(Rs,"immutable"),Rs.forEach(o),B=a(ut," compiler flag"),ut.forEach(o),dt.forEach(o),Y=h(c),O=l(c,"BUTTON",{class:!0});var Ls=r(O);Z=a(Ls,"click me to make number++ go up"),Ls.forEach(o),x=h(c),g=l(c,"H2",{class:!0});var it=r(g);at=a(it,"A. "),ee=l(it,"CODE",{class:!0});var qs=r(ee);v=a(qs,"writable"),qs.forEach(o),At=a(it," store (broken! D:)"),it.forEach(o),It=h(c),S=l(c,"SECTION",{});var ht=r(S);H=l(ht,"DIV",{});var Ve=r(H);le=l(Ve,"SPAN",{class:!0});var js=r(le);st=a(js,Je),js.forEach(o),$t=a(Ve,`
			\u2190 fails to update as a `),oe=l(Ve,"CODE",{class:!0});var Vs=r(oe);St=a(Vs,"writable"),Vs.forEach(o),Ht=a(Ve," store because "),F=l(Ve,"CODE",{class:!0});var vt=r(F);Nt=a(vt,"immutable="),Pt=a(vt,$s),Tt=a(vt,"true}"),vt.forEach(o),Ve.forEach(o),Rt=h(ht),re=l(ht,"PRE",{class:!0});var Ws=r(re);Lt=a(Ws,`$writableMap.set('a', $writableMap.get('a') + 1);
$writableMap = $writableMap;`),Ws.forEach(o),ht.forEach(o),qt=h(c),U=l(c,"H2",{class:!0});var bt=r(U);jt=a(bt,"B. cloned "),ne=l(bt,"CODE",{class:!0});var Bs=r(ne);Vt=a(Bs,"writable"),Bs.forEach(o),Wt=a(bt," store"),bt.forEach(o),Bt=h(c),N=l(c,"SECTION",{});var pt=r(N);ce=l(pt,"DIV",{});var ks=r(ce);de=l(ks,"SPAN",{class:!0});var Fs=r(de);lt=a(Fs,ze),Fs.forEach(o),Ft=a(ks,`
			\u2190 works, but causes heart pain and in some cases tremendous garbage and slowness`),ks.forEach(o),Ut=h(pt),ue=l(pt,"PRE",{class:!0});var Us=r(ue);Kt=a(Us,`$writableMapCloned.set('a', $writableMapCloned.get('a') + 1);
$writableMapCloned = new Map($writableMapCloned);`),Us.forEach(o),pt.forEach(o),Gt=h(c),te=l(c,"BLOCKQUOTE",{});var mt=r(te);Qt=a(mt,"in the examples below, notice that you need to access "),ie=l(mt,"CODE",{class:!0});var Ks=r(ie);Jt=a(Ks,".value"),Ks.forEach(o),zt=a(mt," for reads, unlike above"),mt.forEach(o),Xt=h(c),D=l(c,"H2",{class:!0});var We=r(D);Yt=a(We,"C. "),he=l(We,"CODE",{class:!0});var Gs=r(he);Zt=a(Gs,"derived"),Gs.forEach(o),xt=a(We," from "),ve=l(We,"CODE",{class:!0});var Qs=r(ve);ea=a(Qs,"writable"),Qs.forEach(o),ta=a(We," store"),We.forEach(o),aa=h(c),P=l(c,"SECTION",{});var ft=r(P);be=l(ft,"DIV",{});var As=r(be);pe=l(As,"SPAN",{class:!0});var Js=r(pe);ot=a(Js,Xe),Js.forEach(o),sa=a(As,`
			\u2190 works with no new libraries, and doesn't clone the map, but we're juggling two stores, one for
			writes and one for reads, and it creates garbage every change`),As.forEach(o),la=h(ft),K=l(ft,"PRE",{class:!0});var Et=r(K);oa=a(Et,"const derivedWritableMap = derived(writableMap, ($v) => ("),ra=a(Et,Ss),na=a(Et,"value: $v}));"),Et.forEach(o),ft.forEach(o),ca=h(c),G=l(c,"H2",{class:!0});var _t=r(G);da=a(_t,"D. "),me=l(_t,"CODE",{class:!0});var zs=r(me);ua=a(zs,"mutable"),zs.forEach(o),ia=a(_t," store"),_t.forEach(o),ha=h(c),T=l(c,"SECTION",{});var gt=r(T);R=l(gt,"DIV",{});var Be=r(R);fe=l(Be,"SPAN",{class:!0});var Xs=r(fe);rt=a(Xs,Ye),Xs.forEach(o),va=a(Be,`
			\u2190 works because it's a `),Ee=l(Be,"CODE",{class:!0});var Ys=r(Ee);ba=a(Ys,"mutable"),Ys.forEach(o),pa=a(Be,` store; doesn't clone the map; however notice that
			you need to access `),_e=l(Be,"CODE",{class:!0});var Zs=r(_e);ma=a(Zs,".value"),Zs.forEach(o),Be.forEach(o),fa=h(gt),Q=l(gt,"PRE",{class:!0});var wt=r(Q);Ea=a(wt,"mutableMap.update(($v) => "),_a=a(wt,Hs),ga=a(wt,`
	$v.set('a', $v.get('a') + 1);
});`),wt.forEach(o),gt.forEach(o),wa=h(c),J=l(c,"H2",{class:!0});var Mt=r(J);Ma=a(Mt,"E. "),ge=l(Mt,"CODE",{class:!0});var xs=r(ge);ya=a(xs,"mutable"),xs.forEach(o),Ca=a(Mt," store antipattern"),Mt.forEach(o),Oa=h(c),L=l(c,"SECTION",{});var yt=r(L);k=l(yt,"DIV",{});var ae=r(k);we=l(ae,"SPAN",{class:!0});var el=r(we);nt=a(el,Ze),el.forEach(o),Da=a(ae,`
			\u2190 works because it's a `),Me=l(ae,"CODE",{class:!0});var tl=r(Me);ka=a(tl,"mutable"),tl.forEach(o),Aa=a(ae,` store, but mutates the value directly and then
			manually calls `),ye=l(ae,"CODE",{class:!0});var al=r(ye);Ia=a(al,".update()"),al.forEach(o),$a=a(ae,", which seems like an antipattern"),ae.forEach(o),Sa=h(yt),Ce=l(yt,"PRE",{class:!0});var sl=r(Ce);Ha=a(sl,`$mutableMapAntipattern.value.set('a', $mutableMapAntipattern.value.get('a') + 1);
mutableMapAntipattern.update();`),sl.forEach(o),yt.forEach(o),Na=h(c),z=l(c,"H2",{class:!0});var Ct=r(z);Pa=a(Ct,"F. "),Oe=l(Ct,"CODE",{class:!0});var ll=r(Oe);Ta=a(ll,"fastMutable"),ll.forEach(o),Ra=a(Ct," store"),Ct.forEach(o),La=h(c),q=l(c,"SECTION",{});var Ot=r(q);A=l(Ot,"DIV",{});var se=r(A);De=l(se,"SPAN",{class:!0});var ol=r(De);ct=a(ol,xe),ol.forEach(o),qa=a(se,`
			\u2190 works because it's a `),ke=l(se,"CODE",{class:!0});var rl=r(ke);ja=a(rl,"fastMutable"),rl.forEach(o),Va=a(se,` store, which compared to
			`),Ae=l(se,"CODE",{class:!0});var nl=r(Ae);Wa=a(nl,"mutable"),nl.forEach(o),Ba=a(se,` is slightly more efficient because it swaps between two stable object references,
			but it doesn't compose as an immutable value stream`),se.forEach(o),Fa=h(Ot),X=l(Ot,"PRE",{class:!0});var Dt=r(X);Ua=a(Dt,"fastMutableMap.update(($v) => "),Ka=a(Dt,Ns),Ga=a(Dt,`
	$v.set('a', $v.get('a') + 1);
});`),Dt.forEach(o),Ot.forEach(o),Qa=h(c),Ja=l(c,"HR",{}),za=h(c),Ie=l(c,"H2",{class:!0});var cl=r(Ie);Xa=a(cl,"notes:"),cl.forEach(o),Ya=h(c),_=l(c,"UL",{});var w=r(_);$e=l(w,"LI",{});var Is=r($e);Za=a(Is,"Why care about the immutable option? See this example: "),Se=l(Is,"A",{href:!0});var dl=r(Se);xa=a(dl,"https://svelte.dev/examples/immutable-data"),dl.forEach(o),Is.forEach(o),es=h(w),et=l(w,"LI",{});var ul=r(et);ts=a(ul,`The usecases motivating these stores: large maps and other collections (often containing
			stores) for complex client-side indexing.`),ul.forEach(o),as=h(w),tt=l(w,"LI",{});var il=r(tt);ss=a(il,`Can we solve this problem with a better pattern than these custom stores? Am I missing
			something?`),il.forEach(o),ls=h(w),j=l(w,"LI",{});var Fe=r(j);os=a(Fe,"Is "),He=l(Fe,"CODE",{class:!0});var hl=r(He);rs=a(hl,"fastMutable"),hl.forEach(o),ns=a(Fe,`'s strategy of swapping between two stable references a dangerous
			footgun? It doesn't compose with code that expects every change to be referentially unique.
			Should the `),Ne=l(Fe,"CODE",{class:!0});var vl=r(Ne);cs=a(vl,"mutable"),vl.forEach(o),ds=a(Fe," implementation be preferred in all cases?"),Fe.forEach(o),us=h(w),V=l(w,"LI",{});var Ue=r(V);is=a(Ue,"Are there bettes names than "),Pe=l(Ue,"CODE",{class:!0});var bl=r(Pe);hs=a(bl,"mutable"),bl.forEach(o),vs=a(Ue," and "),Te=l(Ue,"CODE",{class:!0});var pl=r(Te);bs=a(pl,"fastMutable"),pl.forEach(o),ps=a(Ue,"?"),Ue.forEach(o),ms=h(w),W=l(w,"LI",{});var Ke=r(W);fs=a(Ke,"Add a "),Re=l(Ke,"CODE",{class:!0});var ml=r(Re);Es=a(ml,"set"),ml.forEach(o),_s=a(Ke," store method? Probably useful for "),Le=l(Ke,"CODE",{class:!0});var fl=r(Le);gs=a(fl,"bind:"),fl.forEach(o),ws=a(Ke," usage in some cases\n			and less code than `update` to replace references."),Ke.forEach(o),w.forEach(o),Ms=h(c),ys=l(c,"HR",{}),Cs=h(c),qe=l(c,"FOOTER",{class:!0});var El=r(qe);je=l(El,"A",{href:!0});var _l=r(je);Os=a(_l,"public domain source code on GitHub"),_l.forEach(o),El.forEach(o),c.forEach(o),this.h()},h(){d(m,"class","svelte-1hmclby"),d(I,"class","svelte-1hmclby"),d(O,"class","svelte-1hmclby"),d(ee,"class","svelte-1hmclby"),d(g,"class","svelte-1hmclby"),d(le,"class","count svelte-1hmclby"),d(oe,"class","svelte-1hmclby"),d(F,"class","svelte-1hmclby"),d(re,"class","panel-inset svelte-1hmclby"),M(S,"--hue",u[12](u[0].get("a")),!1),d(ne,"class","svelte-1hmclby"),d(U,"class","svelte-1hmclby"),d(de,"class","count svelte-1hmclby"),d(ue,"class","panel-inset svelte-1hmclby"),M(N,"--hue",u[12](u[1].get("a")),!1),d(ie,"class","svelte-1hmclby"),d(he,"class","svelte-1hmclby"),d(ve,"class","svelte-1hmclby"),d(D,"class","svelte-1hmclby"),d(pe,"class","count svelte-1hmclby"),d(K,"class","panel-inset svelte-1hmclby"),M(P,"--hue",u[12](u[3].value.get("a")),!1),d(me,"class","svelte-1hmclby"),d(G,"class","svelte-1hmclby"),d(fe,"class","count svelte-1hmclby"),d(Ee,"class","svelte-1hmclby"),d(_e,"class","svelte-1hmclby"),d(Q,"class","panel-inset svelte-1hmclby"),M(T,"--hue",u[12](u[4].value.get("a")),!1),d(ge,"class","svelte-1hmclby"),d(J,"class","svelte-1hmclby"),d(we,"class","count svelte-1hmclby"),d(Me,"class","svelte-1hmclby"),d(ye,"class","svelte-1hmclby"),d(Ce,"class","panel-inset svelte-1hmclby"),M(L,"--hue",u[12](u[2].value.get("a")),!1),d(Oe,"class","svelte-1hmclby"),d(z,"class","svelte-1hmclby"),d(De,"class","count svelte-1hmclby"),d(ke,"class","svelte-1hmclby"),d(Ae,"class","svelte-1hmclby"),d(X,"class","panel-inset svelte-1hmclby"),M(q,"--hue",u[12](u[5].value.get("a")),!1),d(Ie,"class","svelte-1hmclby"),d(Se,"href","https://svelte.dev/examples/immutable-data"),d(He,"class","svelte-1hmclby"),d(Ne,"class","svelte-1hmclby"),d(Pe,"class","svelte-1hmclby"),d(Te,"class","svelte-1hmclby"),d(Re,"class","svelte-1hmclby"),d(Le,"class","svelte-1hmclby"),d(je,"href","https://github.com/spiderspace/svelte-mutable-store"),d(qe,"class","svelte-1hmclby"),d(n,"class","markup svelte-1hmclby")},m(b,c){Ol(b,n,c),e(n,p),e(p,m),e(m,f),e(p,y),e(p,E),e(E,C),e(E,I),e(I,$),e(E,B),e(n,Y),e(n,O),e(O,Z),e(n,x),e(n,g),e(g,at),e(g,ee),e(ee,v),e(g,At),e(n,It),e(n,S),e(S,H),e(H,le),e(le,st),e(H,$t),e(H,oe),e(oe,St),e(H,Ht),e(H,F),e(F,Nt),e(F,Pt),e(F,Tt),e(S,Rt),e(S,re),e(re,Lt),e(n,qt),e(n,U),e(U,jt),e(U,ne),e(ne,Vt),e(U,Wt),e(n,Bt),e(n,N),e(N,ce),e(ce,de),e(de,lt),e(ce,Ft),e(N,Ut),e(N,ue),e(ue,Kt),e(n,Gt),e(n,te),e(te,Qt),e(te,ie),e(ie,Jt),e(te,zt),e(n,Xt),e(n,D),e(D,Yt),e(D,he),e(he,Zt),e(D,xt),e(D,ve),e(ve,ea),e(D,ta),e(n,aa),e(n,P),e(P,be),e(be,pe),e(pe,ot),e(be,sa),e(P,la),e(P,K),e(K,oa),e(K,ra),e(K,na),e(n,ca),e(n,G),e(G,da),e(G,me),e(me,ua),e(G,ia),e(n,ha),e(n,T),e(T,R),e(R,fe),e(fe,rt),e(R,va),e(R,Ee),e(Ee,ba),e(R,pa),e(R,_e),e(_e,ma),e(T,fa),e(T,Q),e(Q,Ea),e(Q,_a),e(Q,ga),e(n,wa),e(n,J),e(J,Ma),e(J,ge),e(ge,ya),e(J,Ca),e(n,Oa),e(n,L),e(L,k),e(k,we),e(we,nt),e(k,Da),e(k,Me),e(Me,ka),e(k,Aa),e(k,ye),e(ye,Ia),e(k,$a),e(L,Sa),e(L,Ce),e(Ce,Ha),e(n,Na),e(n,z),e(z,Pa),e(z,Oe),e(Oe,Ta),e(z,Ra),e(n,La),e(n,q),e(q,A),e(A,De),e(De,ct),e(A,qa),e(A,ke),e(ke,ja),e(A,Va),e(A,Ae),e(Ae,Wa),e(A,Ba),e(q,Fa),e(q,X),e(X,Ua),e(X,Ka),e(X,Ga),e(n,Qa),e(n,Ja),e(n,za),e(n,Ie),e(Ie,Xa),e(n,Ya),e(n,_),e(_,$e),e($e,Za),e($e,Se),e(Se,xa),e(_,es),e(_,et),e(et,ts),e(_,as),e(_,tt),e(tt,ss),e(_,ls),e(_,j),e(j,os),e(j,He),e(He,rs),e(j,ns),e(j,Ne),e(Ne,cs),e(j,ds),e(_,us),e(_,V),e(V,is),e(V,Pe),e(Pe,hs),e(V,vs),e(V,Te),e(Te,bs),e(V,ps),e(_,ms),e(_,W),e(W,fs),e(W,Re),e(Re,Es),e(W,_s),e(W,Le),e(Le,gs),e(W,ws),e(n,Ms),e(n,ys),e(n,Cs),e(n,qe),e(qe,je),e(je,Os),Ds||(Ps=Dl(O,"click",u[13]),Ds=!0)},p(b,[c]){c&1&&Je!==(Je=b[0].get("a")+"")&&Ge(st,Je),c&1&&M(S,"--hue",b[12](b[0].get("a")),!1),c&2&&ze!==(ze=b[1].get("a")+"")&&Ge(lt,ze),c&2&&M(N,"--hue",b[12](b[1].get("a")),!1),c&8&&Xe!==(Xe=b[3].value.get("a")+"")&&Ge(ot,Xe),c&8&&M(P,"--hue",b[12](b[3].value.get("a")),!1),c&16&&Ye!==(Ye=b[4].value.get("a")+"")&&Ge(rt,Ye),c&16&&M(T,"--hue",b[12](b[4].value.get("a")),!1),c&4&&Ze!==(Ze=b[2].value.get("a")+"")&&Ge(nt,Ze),c&4&&M(L,"--hue",b[12](b[2].value.get("a")),!1),c&32&&xe!==(xe=b[5].value.get("a")+"")&&Ge(ct,xe),c&32&&M(q,"--hue",b[12](b[5].value.get("a")),!1)},i:gl,o:gl,d(b){b&&o(n),Ds=!1,Ps()}}}function Sl(u,n,p){let m,f,y,E,C,I;const $=[["a",1]],B=kt(new Map($));Qe(u,B,v=>p(0,m=v));const Y=kt(new Map($));Qe(u,Y,v=>p(1,f=v));const O=kl(B,v=>({value:v}));Qe(u,O,v=>p(3,E=v));const Z=wl(new Map($));Qe(u,Z,v=>p(4,C=v));const x=wl(new Map($));Qe(u,x,v=>p(2,y=v));const g=Il(new Map($));return Qe(u,g,v=>p(5,I=v)),[m,f,y,E,C,I,B,Y,O,Z,x,g,v=>v*37+"",()=>{m.set("a",m.get("a")+1),B.set(m),f.set("a",f.get("a")+1),Al(Y,f=new Map(f),f),Z.update(v=>{v.set("a",v.get("a")+1)}),y.value.set("a",y.value.get("a")+1),x.update(),g.update(v=>{v.set("a",v.get("a")+1)})}]}class Nl extends Ml{constructor(n){super();yl(this,n,Sl,$l,Cl,{})}}export{Nl as default};
